/*
 * BrAPI-Phenotyping
 * The Breeding API (BrAPI) is a Standardized REST ful Web Service API Specification for communicating Plant Breeding Data. BrAPI allows for easy data sharing between databases and tools involved in plant breeding. <div class=\"brapi-section\"> <h2 class=\"brapi-section-title\">General Reference Documentation</h2> <div class=\"gen-info-link\"><a href=\"https://wiki.brapi.org/index.php/RESTfulness\">URL Structure</a></div> <div class=\"gen-info-link\"><a href=\"https://wiki.brapi.org/index.php/Response_Structure\">Response Structure</a></div> <div class=\"gen-info-link\"><a href=\"https://wiki.brapi.org/index.php/Dates_and_Times\">Date/Time Encoding</a></div> <div class=\"gen-info-link\"><a href=\"https://wiki.brapi.org/index.php/Location_Coordinates\">Location Encoding</a></div> <div class=\"gen-info-link\"><a href=\"https://wiki.brapi.org/index.php/Error_Handling\">Error Handling</a></div> <div class=\"gen-info-link\"><a href=\"https://wiki.brapi.org/index.php/Search_Services\">Search Services</a></div> </div>  <div class=\"brapi-section\"> <h2 class=\"brapi-section-title\">BrAPI Core</h2> <div class=\"brapi-section-description\">The BrAPI Core module contains high level entities used for organization and management. This includes Programs, Trials, Studies, Locations, People, and Lists</div> <div class=\"version-number\">V2.1</div> <div class=\"link-btn\"><a href=\"https://github.com/plantbreeding/API/tree/brapi-V2.1/Specification/BrAPI-Core\">GitHub</a></div> <div class=\"link-btn\"><a href=\"https://app.swaggerhub.com/apis/PlantBreedingAPI/BrAPI-Core/2.1\">SwaggerHub</a></div> <div class=\"link-btn\"><a href=\"https://brapicore21.docs.apiary.io\">Apiary</a></div> <div class=\"stop-float\"></div> </div>  <div class=\"current-brapi-section brapi-section\"> <h2 class=\"brapi-section-title\">BrAPI Phenotyping</h2> <div class=\"brapi-section-description\">The BrAPI Phenotyping module contains entities related to phenotypic observations. This includes Observation Units, Observations, Observation Variables, Traits, Scales, Methods, and Images</div> <div class=\"version-number\">V2.1</div> <div class=\"link-btn\"><a href=\"https://github.com/plantbreeding/API/tree/brapi-V2.1/Specification/BrAPI-Phenotyping\">GitHub</a></div> <div class=\"link-btn\"><a href=\"https://app.swaggerhub.com/apis/PlantBreedingAPI/BrAPI-Phenotyping/2.1\">SwaggerHub</a></div> <div class=\"link-btn\"><a href=\"https://brapiphenotyping21.docs.apiary.io\">Apiary</a></div> <div class=\"stop-float\"></div> </div>  <div class=\"brapi-section\"> <h2 class=\"brapi-section-title\">BrAPI Genotyping</h2> <div class=\"brapi-section-description\">The BrAPI Genotyping module contains entities related to genotyping analysis. This includes Samples, Markers, Variant Sets, Variants, Call Sets, Calls, References, Reads, and Vendor Orders</div> <div class=\"version-number\">V2.1</div> <div class=\"link-btn\"><a href=\"https://github.com/plantbreeding/API/tree/brapi-V2.1/Specification/BrAPI-Genotyping\">GitHub</a></div> <div class=\"link-btn\"><a href=\"https://app.swaggerhub.com/apis/PlantBreedingAPI/BrAPI-Genotyping/2.1\">SwaggerHub</a></div> <div class=\"link-btn\"><a href=\"https://brapigenotyping21.docs.apiary.io\">Apiary</a></div> <div class=\"stop-float\"></div> </div>  <div class=\"brapi-section\"> <h2 class=\"brapi-section-title\">BrAPI Germplasm</h2> <div class=\"brapi-section-description\">The BrAPI Germplasm module contains entities related to germplasm management. This includes Germplasm, Germplasm Attributes, Seed Lots, Crosses, Pedigree, and Progeny</div> <div class=\"version-number\">V2.1</div> <div class=\"link-btn\"><a href=\"https://github.com/plantbreeding/API/tree/brapi-V2.1/Specification/BrAPI-Germplasm\">GitHub</a></div> <div class=\"link-btn\"><a href=\"https://app.swaggerhub.com/apis/PlantBreedingAPI/BrAPI-Germplasm/2.1\">SwaggerHub</a></div> <div class=\"link-btn\"><a href=\"https://brapigermplasm21.docs.apiary.io\">Apiary</a></div> <div class=\"stop-float\"></div> </div>  <style> .link-btn{ float: left;  margin: 2px 10px 0 0;  padding: 0 5px;  border-radius: 5px;  background-color: #ddd; } .stop-float{   clear: both; } .version-number{   float: left;    margin: 5px 10px 0 5px; } .brapi-section-title{   margin: 0 10px 0 0;   font-size: 20px; } .current-brapi-section{   font-weight: bolder;   border-radius: 5px;    background-color: #ddd; } .brapi-section{   padding: 5px 5px;  } .brapi-section-description{   margin: 5px 0 0 5px; } </style>
 *
 * OpenAPI spec version: 2.1
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package org.brapi.client.v21.modules.phenotype;

import com.google.gson.reflect.TypeToken;
import org.brapi.client.v21.*;
import org.brapi.client.v21.model.queryParams.phenotype.ObservationQueryParams;
import org.brapi.model.v21.phenotype.*;
import org.threeten.bp.OffsetDateTime;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class ObservationsApi {
    private ApiClient apiClient;

    public ObservationsApi() {
        this(Configuration.getDefaultApiClient());
    }

    public ObservationsApi(ApiClient apiClient) {
        this.apiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return apiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.apiClient = apiClient;
    }

    /**
     * Build call for deleteObservationsPost
     *
     * @param body                    (optional)
     * @param authorization           HTTP HEADER - Token used for Authorization   &lt;strong&gt; Bearer {token_string} &lt;/strong&gt; (optional)
     * @param progressListener        Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call deleteObservationsPostCall(ObservationSearchRequest body, String authorization, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {

        // create path and map variables
        String localVarPath = "/delete/observations";

        List<Pair> localVarQueryParams = new ArrayList<>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<>();

        Map<String, String> localVarHeaderParams = new HashMap<>();
        if (authorization != null)
            localVarHeaderParams.put("Authorization", apiClient.parameterToString(authorization));

        Map<String, Object> localVarFormParams = new HashMap<>();

        final String[] localVarAccepts = {
                "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
                "application/json"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if (progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(chain -> {
                com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                return originalResponse.newBuilder()
                        .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                        .build();
            });
        }

        String[] localVarAuthNames = new String[]{"AuthorizationToken"};
        return apiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, body, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    private com.squareup.okhttp.Call deleteObservationsPostValidateBeforeCall(ObservationSearchRequest body, String authorization, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {

        return deleteObservationsPostCall(body, authorization, progressListener, progressRequestListener);


    }

    /**
     * Submit a delete request for &#x60;Observations&#x60;
     * Submit a delete request for &#x60;Observations&#x60;
     *
     * @param body          (optional)
     * @param authorization HTTP HEADER - Token used for Authorization   &lt;strong&gt; Bearer {token_string} &lt;/strong&gt; (optional)
     * @return ObservationDeleteResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ObservationDeleteResponse deleteObservationsPost(ObservationSearchRequest body, String authorization) throws ApiException {
        ApiResponse<ObservationDeleteResponse> resp = deleteObservationsPostWithHttpInfo(body, authorization);
        return resp.getData();
    }

    /**
     * Submit a delete request for &#x60;Observations&#x60;
     * Submit a delete request for &#x60;Observations&#x60;
     *
     * @param body          (optional)
     * @param authorization HTTP HEADER - Token used for Authorization   &lt;strong&gt; Bearer {token_string} &lt;/strong&gt; (optional)
     * @return ApiResponse&lt;ObservationDeleteResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<ObservationDeleteResponse> deleteObservationsPostWithHttpInfo(ObservationSearchRequest body, String authorization) throws ApiException {
        com.squareup.okhttp.Call call = deleteObservationsPostValidateBeforeCall(body, authorization, null, null);
        Type localVarReturnType = new TypeToken<ObservationDeleteResponse>() {
        }.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Submit a delete request for &#x60;Observations&#x60; (asynchronously)
     * Submit a delete request for &#x60;Observations&#x60;
     *
     * @param body          (optional)
     * @param authorization HTTP HEADER - Token used for Authorization   &lt;strong&gt; Bearer {token_string} &lt;/strong&gt; (optional)
     * @param callback      The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call deleteObservationsPostAsync(ObservationSearchRequest body, String authorization, final ApiCallback<ObservationDeleteResponse> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = callback::onDownloadProgress;

            progressRequestListener = callback::onUploadProgress;
        }

        com.squareup.okhttp.Call call = deleteObservationsPostValidateBeforeCall(body, authorization, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<ObservationDeleteResponse>() {
        }.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }

    /**
     * Build call for observationsGet
     *
     * @param progressListener        Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call observationsGetCall(ObservationQueryParams queryParams, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/observations";

        List<Pair> localVarQueryParams = new ArrayList<>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<>();

        Map<String, String> localVarHeaderParams = new HashMap<>();

        queryParams.buildQueryParams(apiClient, localVarQueryParams, localVarHeaderParams);

        Map<String, Object> localVarFormParams = new HashMap<>();

        final String[] localVarAccepts = {
                "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {

        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if (progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(chain -> {
                com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                return originalResponse.newBuilder()
                        .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                        .build();
            });
        }

        String[] localVarAuthNames = new String[]{"AuthorizationToken"};
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    private com.squareup.okhttp.Call observationsGetValidateBeforeCall(ObservationQueryParams queryParams, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {

        return observationsGetCall(queryParams, progressListener, progressRequestListener);


    }

    /**
     * Get a filtered set of Observations
     * Retrieve all observations where there are measurements for the given observation variables.   observationTimestamp should be ISO8601 format with timezone -&gt; YYYY-MM-DDThh:mm:ss+hhmm
     *
     * @return ObservationListResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ObservationListResponse observationsGet(ObservationQueryParams queryParams) throws ApiException {
        ApiResponse<ObservationListResponse> resp = observationsGetWithHttpInfo(queryParams);
        return resp.getData();
    }

    /**
     * Get a filtered set of Observations
     * Retrieve all observations where there are measurements for the given observation variables.   observationTimestamp should be ISO8601 format with timezone -&gt; YYYY-MM-DDThh:mm:ss+hhmm
     *
     * @return ApiResponse&lt;ObservationListResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<ObservationListResponse> observationsGetWithHttpInfo(ObservationQueryParams queryParams) throws ApiException {
        com.squareup.okhttp.Call call = observationsGetValidateBeforeCall(queryParams, null, null);
        Type localVarReturnType = new TypeToken<ObservationListResponse>() {
        }.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Get a filtered set of Observations (asynchronously)
     * Retrieve all observations where there are measurements for the given observation variables.   observationTimestamp should be ISO8601 format with timezone -&gt; YYYY-MM-DDThh:mm:ss+hhmm
     *
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call observationsGetAsync(ObservationQueryParams queryParams, final ApiCallback<ObservationListResponse> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = callback::onDownloadProgress;

            progressRequestListener = callback::onUploadProgress;
        }

        com.squareup.okhttp.Call call = observationsGetValidateBeforeCall(queryParams, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<ObservationListResponse>() {
        }.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }

    /**
     * Build call for observationsObservationDbIdGet
     *
     * @param observationDbId         The unique ID of an observation (required)
     * @param authorization           HTTP HEADER - Token used for Authorization   &lt;strong&gt; Bearer {token_string} &lt;/strong&gt; (optional)
     * @param progressListener        Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call observationsObservationDbIdGetCall(String observationDbId, String authorization, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/observations/{observationDbId}"
                .replaceAll("\\{" + "observationDbId" + "}", apiClient.escapeString(observationDbId));

        List<Pair> localVarQueryParams = new ArrayList<>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<>();

        Map<String, String> localVarHeaderParams = new HashMap<>();
        if (authorization != null)
            localVarHeaderParams.put("Authorization", apiClient.parameterToString(authorization));

        Map<String, Object> localVarFormParams = new HashMap<>();

        final String[] localVarAccepts = {
                "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {

        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if (progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(chain -> {
                com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                return originalResponse.newBuilder()
                        .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                        .build();
            });
        }

        String[] localVarAuthNames = new String[]{"AuthorizationToken"};
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    private com.squareup.okhttp.Call observationsObservationDbIdGetValidateBeforeCall(String observationDbId, String authorization, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        // verify the required parameter 'observationDbId' is set
        if (observationDbId == null) {
            throw new ApiException("Missing the required parameter 'observationDbId' when calling observationsObservationDbIdGet(Async)");
        }

        return observationsObservationDbIdGetCall(observationDbId, authorization, progressListener, progressRequestListener);


    }

    /**
     * Get the details of a specific Observations
     * Get the details of a specific Observations  observationTimestamp should be ISO8601 format with timezone -&gt; YYYY-MM-DDThh:mm:ss+hhmm
     *
     * @param observationDbId The unique ID of an observation (required)
     * @param authorization   HTTP HEADER - Token used for Authorization   &lt;strong&gt; Bearer {token_string} &lt;/strong&gt; (optional)
     * @return ObservationSingleResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ObservationSingleResponse observationsObservationDbIdGet(String observationDbId, String authorization) throws ApiException {
        ApiResponse<ObservationSingleResponse> resp = observationsObservationDbIdGetWithHttpInfo(observationDbId, authorization);
        return resp.getData();
    }

    /**
     * Get the details of a specific Observations
     * Get the details of a specific Observations  observationTimestamp should be ISO8601 format with timezone -&gt; YYYY-MM-DDThh:mm:ss+hhmm
     *
     * @param observationDbId The unique ID of an observation (required)
     * @param authorization   HTTP HEADER - Token used for Authorization   &lt;strong&gt; Bearer {token_string} &lt;/strong&gt; (optional)
     * @return ApiResponse&lt;ObservationSingleResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<ObservationSingleResponse> observationsObservationDbIdGetWithHttpInfo(String observationDbId, String authorization) throws ApiException {
        com.squareup.okhttp.Call call = observationsObservationDbIdGetValidateBeforeCall(observationDbId, authorization, null, null);
        Type localVarReturnType = new TypeToken<ObservationSingleResponse>() {
        }.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Get the details of a specific Observations (asynchronously)
     * Get the details of a specific Observations  observationTimestamp should be ISO8601 format with timezone -&gt; YYYY-MM-DDThh:mm:ss+hhmm
     *
     * @param observationDbId The unique ID of an observation (required)
     * @param authorization   HTTP HEADER - Token used for Authorization   &lt;strong&gt; Bearer {token_string} &lt;/strong&gt; (optional)
     * @param callback        The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call observationsObservationDbIdGetAsync(String observationDbId, String authorization, final ApiCallback<ObservationSingleResponse> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = callback::onDownloadProgress;

            progressRequestListener = callback::onUploadProgress;
        }

        com.squareup.okhttp.Call call = observationsObservationDbIdGetValidateBeforeCall(observationDbId, authorization, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<ObservationSingleResponse>() {
        }.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }

    /**
     * Build call for observationsObservationDbIdPut
     *
     * @param observationDbId         The unique ID of an observation (required)
     * @param body                    (optional)
     * @param authorization           HTTP HEADER - Token used for Authorization   &lt;strong&gt; Bearer {token_string} &lt;/strong&gt; (optional)
     * @param progressListener        Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call observationsObservationDbIdPutCall(String observationDbId, ObservationNewRequest body, String authorization, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {

        // create path and map variables
        String localVarPath = "/observations/{observationDbId}"
                .replaceAll("\\{" + "observationDbId" + "}", apiClient.escapeString(observationDbId));

        List<Pair> localVarQueryParams = new ArrayList<>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<>();

        Map<String, String> localVarHeaderParams = new HashMap<>();
        if (authorization != null)
            localVarHeaderParams.put("Authorization", apiClient.parameterToString(authorization));

        Map<String, Object> localVarFormParams = new HashMap<>();

        final String[] localVarAccepts = {
                "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
                "application/json"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if (progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(chain -> {
                com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                return originalResponse.newBuilder()
                        .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                        .build();
            });
        }

        String[] localVarAuthNames = new String[]{"AuthorizationToken"};
        return apiClient.buildCall(localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, body, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    private com.squareup.okhttp.Call observationsObservationDbIdPutValidateBeforeCall(String observationDbId, ObservationNewRequest body, String authorization, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        // verify the required parameter 'observationDbId' is set
        if (observationDbId == null) {
            throw new ApiException("Missing the required parameter 'observationDbId' when calling observationsObservationDbIdPut(Async)");
        }

        return observationsObservationDbIdPutCall(observationDbId, body, authorization, progressListener, progressRequestListener);


    }

    /**
     * Update an existing Observation
     * Update an existing Observation
     *
     * @param observationDbId The unique ID of an observation (required)
     * @param body            (optional)
     * @param authorization   HTTP HEADER - Token used for Authorization   &lt;strong&gt; Bearer {token_string} &lt;/strong&gt; (optional)
     * @return ObservationSingleResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ObservationSingleResponse observationsObservationDbIdPut(String observationDbId, ObservationNewRequest body, String authorization) throws ApiException {
        ApiResponse<ObservationSingleResponse> resp = observationsObservationDbIdPutWithHttpInfo(observationDbId, body, authorization);
        return resp.getData();
    }

    /**
     * Update an existing Observation
     * Update an existing Observation
     *
     * @param observationDbId The unique ID of an observation (required)
     * @param body            (optional)
     * @param authorization   HTTP HEADER - Token used for Authorization   &lt;strong&gt; Bearer {token_string} &lt;/strong&gt; (optional)
     * @return ApiResponse&lt;ObservationSingleResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<ObservationSingleResponse> observationsObservationDbIdPutWithHttpInfo(String observationDbId, ObservationNewRequest body, String authorization) throws ApiException {
        com.squareup.okhttp.Call call = observationsObservationDbIdPutValidateBeforeCall(observationDbId, body, authorization, null, null);
        Type localVarReturnType = new TypeToken<ObservationSingleResponse>() {
        }.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Update an existing Observation (asynchronously)
     * Update an existing Observation
     *
     * @param observationDbId The unique ID of an observation (required)
     * @param body            (optional)
     * @param authorization   HTTP HEADER - Token used for Authorization   &lt;strong&gt; Bearer {token_string} &lt;/strong&gt; (optional)
     * @param callback        The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call observationsObservationDbIdPutAsync(String observationDbId, ObservationNewRequest body, String authorization, final ApiCallback<ObservationSingleResponse> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = callback::onDownloadProgress;

            progressRequestListener = callback::onUploadProgress;
        }

        com.squareup.okhttp.Call call = observationsObservationDbIdPutValidateBeforeCall(observationDbId, body, authorization, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<ObservationSingleResponse>() {
        }.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }

    /**
     * Build call for observationsPost
     *
     * @param body                    (optional)
     * @param authorization           HTTP HEADER - Token used for Authorization   &lt;strong&gt; Bearer {token_string} &lt;/strong&gt; (optional)
     * @param progressListener        Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call observationsPostCall(List<ObservationNewRequest> body, String authorization, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {

        // create path and map variables
        String localVarPath = "/observations";

        List<Pair> localVarQueryParams = new ArrayList<>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<>();

        Map<String, String> localVarHeaderParams = new HashMap<>();
        if (authorization != null)
            localVarHeaderParams.put("Authorization", apiClient.parameterToString(authorization));

        Map<String, Object> localVarFormParams = new HashMap<>();

        final String[] localVarAccepts = {
                "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
                "application/json"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if (progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(chain -> {
                com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                return originalResponse.newBuilder()
                        .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                        .build();
            });
        }

        String[] localVarAuthNames = new String[]{"AuthorizationToken"};
        return apiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, body, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    private com.squareup.okhttp.Call observationsPostValidateBeforeCall(List<ObservationNewRequest> body, String authorization, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {

        return observationsPostCall(body, authorization, progressListener, progressRequestListener);


    }

    /**
     * Add new Observation entities
     * Add new Observation entities
     *
     * @param body          (optional)
     * @param authorization HTTP HEADER - Token used for Authorization   &lt;strong&gt; Bearer {token_string} &lt;/strong&gt; (optional)
     * @return ObservationListResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ObservationListResponse observationsPost(List<ObservationNewRequest> body, String authorization) throws ApiException {
        ApiResponse<ObservationListResponse> resp = observationsPostWithHttpInfo(body, authorization);
        return resp.getData();
    }

    /**
     * Add new Observation entities
     * Add new Observation entities
     *
     * @param body          (optional)
     * @param authorization HTTP HEADER - Token used for Authorization   &lt;strong&gt; Bearer {token_string} &lt;/strong&gt; (optional)
     * @return ApiResponse&lt;ObservationListResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<ObservationListResponse> observationsPostWithHttpInfo(List<ObservationNewRequest> body, String authorization) throws ApiException {
        com.squareup.okhttp.Call call = observationsPostValidateBeforeCall(body, authorization, null, null);
        Type localVarReturnType = new TypeToken<ObservationListResponse>() {
        }.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Add new Observation entities (asynchronously)
     * Add new Observation entities
     *
     * @param body          (optional)
     * @param authorization HTTP HEADER - Token used for Authorization   &lt;strong&gt; Bearer {token_string} &lt;/strong&gt; (optional)
     * @param callback      The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call observationsPostAsync(List<ObservationNewRequest> body, String authorization, final ApiCallback<ObservationListResponse> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = callback::onDownloadProgress;

            progressRequestListener = callback::onUploadProgress;
        }

        com.squareup.okhttp.Call call = observationsPostValidateBeforeCall(body, authorization, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<ObservationListResponse>() {
        }.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }

    /**
     * Build call for observationsPut
     *
     * @param body                    (optional)
     * @param authorization           HTTP HEADER - Token used for Authorization   &lt;strong&gt; Bearer {token_string} &lt;/strong&gt; (optional)
     * @param progressListener        Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call observationsPutCall(Map<String, ObservationNewRequest> body, String authorization, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {

        // create path and map variables
        String localVarPath = "/observations";

        List<Pair> localVarQueryParams = new ArrayList<>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<>();

        Map<String, String> localVarHeaderParams = new HashMap<>();
        if (authorization != null)
            localVarHeaderParams.put("Authorization", apiClient.parameterToString(authorization));

        Map<String, Object> localVarFormParams = new HashMap<>();

        final String[] localVarAccepts = {
                "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
                "application/json"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if (progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(chain -> {
                com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                return originalResponse.newBuilder()
                        .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                        .build();
            });
        }

        String[] localVarAuthNames = new String[]{"AuthorizationToken"};
        return apiClient.buildCall(localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, body, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    private com.squareup.okhttp.Call observationsPutValidateBeforeCall(Map<String, ObservationNewRequest> body, String authorization, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {

        return observationsPutCall(body, authorization, progressListener, progressRequestListener);


    }

    /**
     * Update multiple Observation entities
     * Update multiple Observation entities simultaneously with a single call   Include as many &#x60;observationDbIds&#x60; in the request as needed.   Note - In strictly typed languages, this structure can be represented as a Map or Dictionary of objects and parsed directly from JSON.
     *
     * @param body          (optional)
     * @param authorization HTTP HEADER - Token used for Authorization   &lt;strong&gt; Bearer {token_string} &lt;/strong&gt; (optional)
     * @return ObservationListResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ObservationListResponse observationsPut(Map<String, ObservationNewRequest> body, String authorization) throws ApiException {
        ApiResponse<ObservationListResponse> resp = observationsPutWithHttpInfo(body, authorization);
        return resp.getData();
    }

    /**
     * Update multiple Observation entities
     * Update multiple Observation entities simultaneously with a single call   Include as many &#x60;observationDbIds&#x60; in the request as needed.   Note - In strictly typed languages, this structure can be represented as a Map or Dictionary of objects and parsed directly from JSON.
     *
     * @param body          (optional)
     * @param authorization HTTP HEADER - Token used for Authorization   &lt;strong&gt; Bearer {token_string} &lt;/strong&gt; (optional)
     * @return ApiResponse&lt;ObservationListResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<ObservationListResponse> observationsPutWithHttpInfo(Map<String, ObservationNewRequest> body, String authorization) throws ApiException {
        com.squareup.okhttp.Call call = observationsPutValidateBeforeCall(body, authorization, null, null);
        Type localVarReturnType = new TypeToken<ObservationListResponse>() {
        }.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Update multiple Observation entities (asynchronously)
     * Update multiple Observation entities simultaneously with a single call   Include as many &#x60;observationDbIds&#x60; in the request as needed.   Note - In strictly typed languages, this structure can be represented as a Map or Dictionary of objects and parsed directly from JSON.
     *
     * @param body          (optional)
     * @param authorization HTTP HEADER - Token used for Authorization   &lt;strong&gt; Bearer {token_string} &lt;/strong&gt; (optional)
     * @param callback      The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call observationsPutAsync(Map<String, ObservationNewRequest> body, String authorization, final ApiCallback<ObservationListResponse> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = callback::onDownloadProgress;

            progressRequestListener = callback::onUploadProgress;
        }

        com.squareup.okhttp.Call call = observationsPutValidateBeforeCall(body, authorization, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<ObservationListResponse>() {
        }.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }

    /**
     * Build call for observationsTableGet
     *
     * @param accept                                A standard HTTP request header that is used to request a specific content type (JSON, CSV, etc) which is \&quot;acceptable\&quot; to the client and should be returned by the server (required)
     * @param observationUnitDbId                   The unique ID of an Observation Unit (optional)
     * @param observationVariableDbId               The unique ID of an observation variable (optional)
     * @param locationDbId                          The unique ID of a location where these observations were collected (optional)
     * @param seasonDbId                            The year or Phenotyping campaign of a multi-annual study (trees, grape, ...) (optional)
     * @param observationLevel                      **Deprecated in v2.1** Please use &#x60;observationUnitLevelName&#x60;. Github issue number #464  &lt;br&gt;The type of the observationUnit. Returns only the observation unit of the specified type; the parent levels ID can be accessed through observationUnitStructure.  (optional)
     * @param searchResultsDbId                     Permanent unique identifier which references the search results (optional)
     * @param observationTimeStampRangeStart        Timestamp range start (optional)
     * @param observationTimeStampRangeEnd          Timestamp range end (optional)
     * @param programDbId                           Use this parameter to only return results associated with the given &#x60;Program&#x60; unique identifier.  &lt;br/&gt;Use &#x60;GET /programs&#x60; to find the list of available &#x60;Programs&#x60; on a server. (optional)
     * @param trialDbId                             Use this parameter to only return results associated with the given &#x60;Trial&#x60; unique identifier.  &lt;br/&gt;Use &#x60;GET /trials&#x60; to find the list of available &#x60;Trials&#x60; on a server. (optional)
     * @param studyDbId                             Use this parameter to only return results associated with the given &#x60;Study&#x60; unique identifier.  &lt;br/&gt;Use &#x60;GET /studies&#x60; to find the list of available &#x60;Studies&#x60; on a server. (optional)
     * @param germplasmDbId                         Use this parameter to only return results associated with the given &#x60;Germplasm&#x60; unique identifier.  &lt;br/&gt;Use &#x60;GET /germplasm&#x60; to find the list of available &#x60;Germplasm&#x60; on a server. (optional)
     * @param observationUnitLevelName              The Observation Unit Level. Returns only the observation unit of the specified Level.  &lt;br/&gt;References ObservationUnit-&gt;observationUnitPosition-&gt;observationLevel-&gt;levelName  &lt;br/&gt;**Standard Level Names: study, field, entry, rep, block, sub-block, plot, sub-plot, plant, pot, sample**  &lt;br/&gt;For more information on Observation Levels, please review the &lt;a target&#x3D;\&quot;_blank\&quot; href&#x3D;\&quot;https://wiki.brapi.org/index.php/Observation_Levels\&quot;&gt;Observation Levels documentation&lt;/a&gt;.  (optional)
     * @param observationUnitLevelOrder             The Observation Unit Level Order Number. Returns only the observation unit of the specified Level.  References ObservationUnit-&gt;observationUnitPosition-&gt;observationLevel-&gt;levelOrder  &lt;br/&gt;For more information on Observation Levels, please review the &lt;a target&#x3D;\&quot;_blank\&quot; href&#x3D;\&quot;https://wiki.brapi.org/index.php/Observation_Levels\&quot;&gt;Observation Levels documentation&lt;/a&gt;.  (optional)
     * @param observationUnitLevelCode              The Observation Unit Level Code. This parameter should be used together with &#x60;observationUnitLevelName&#x60;  or &#x60;observationUnitLevelOrder&#x60;. References ObservationUnit-&gt;observationUnitPosition-&gt;observationLevel-&gt;levelCode  &lt;br/&gt;For more information on Observation Levels, please review the &lt;a target&#x3D;\&quot;_blank\&quot; href&#x3D;\&quot;https://wiki.brapi.org/index.php/Observation_Levels\&quot;&gt;Observation Levels documentation&lt;/a&gt;.  (optional)
     * @param observationUnitLevelRelationshipName  The Observation Unit Level Relationship is a connection that this observation unit has to another level of the hierarchy.  &lt;br/&gt;For example, if you have several observation units at a &#x27;plot&#x27; level, they might all share a relationship to the same &#x27;field&#x27; level.   &lt;br/&gt;Use this parameter to identify groups of observation units that share a relationship level.  &lt;br/&gt;**Standard Level Names: study, field, entry, rep, block, sub-block, plot, sub-plot, plant, pot, sample**  &lt;br/&gt;For more information on Observation Levels, please review the &lt;a target&#x3D;\&quot;_blank\&quot; href&#x3D;\&quot;https://wiki.brapi.org/index.php/Observation_Levels\&quot;&gt;Observation Levels documentation&lt;/a&gt;.  (optional)
     * @param observationUnitLevelRelationshipOrder The Observation Unit Level Order Number.  &lt;br/&gt;Returns only the observation unit of the specified Level. References ObservationUnit-&gt;observationUnitPosition-&gt;observationLevel-&gt;levelOrder  &lt;br/&gt;For more information on Observation Levels, please review the &lt;a target&#x3D;\&quot;_blank\&quot; href&#x3D;\&quot;https://wiki.brapi.org/index.php/Observation_Levels\&quot;&gt;Observation Levels documentation&lt;/a&gt;.  (optional)
     * @param observationUnitLevelRelationshipCode  The Observation Unit Level Code.  &lt;br/&gt;This parameter should be used together with &#x60;observationUnitLevelName&#x60; or &#x60;observationUnitLevelOrder&#x60;. References ObservationUnit-&gt;observationUnitPosition-&gt;observationLevel-&gt;levelCode  &lt;br/&gt;For more information on Observation Levels, please review the &lt;a target&#x3D;\&quot;_blank\&quot; href&#x3D;\&quot;https://wiki.brapi.org/index.php/Observation_Levels\&quot;&gt;Observation Levels documentation&lt;/a&gt;.  (optional)
     * @param observationUnitLevelRelationshipDbId  The observationUnitDbId associated with a particular level and code. &lt;br/&gt;This parameter should be used together with &#x60;observationUnitLevelName&#x60; or &#x60;observationUnitLevelOrder&#x60;. References ObservationUnit-&gt;observationUnitPosition-&gt;observationLevel-&gt;observationUnitDbId  &lt;br/&gt;For more information on Observation Levels, please review the &lt;a target&#x3D;\&quot;_blank\&quot; href&#x3D;\&quot;https://wiki.brapi.org/index.php/Observation_Levels\&quot;&gt;Observation Levels documentation&lt;/a&gt;.  (optional)
     * @param authorization                         HTTP HEADER - Token used for Authorization   &lt;strong&gt; Bearer {token_string} &lt;/strong&gt; (optional)
     * @param progressListener                      Progress listener
     * @param progressRequestListener               Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call observationsTableGetCall(ContentTypes accept, String observationUnitDbId, String observationVariableDbId, String locationDbId, String seasonDbId, String observationLevel, String searchResultsDbId, OffsetDateTime observationTimeStampRangeStart, OffsetDateTime observationTimeStampRangeEnd, String programDbId, String trialDbId, String studyDbId, String germplasmDbId, String observationUnitLevelName, String observationUnitLevelOrder, String observationUnitLevelCode, String observationUnitLevelRelationshipName, String observationUnitLevelRelationshipOrder, String observationUnitLevelRelationshipCode, String observationUnitLevelRelationshipDbId, String authorization, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/observations/table";

        List<Pair> localVarQueryParams = new ArrayList<>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<>();
        if (observationUnitDbId != null)
            localVarQueryParams.addAll(apiClient.parameterToPair("observationUnitDbId", observationUnitDbId));
        if (observationVariableDbId != null)
            localVarQueryParams.addAll(apiClient.parameterToPair("observationVariableDbId", observationVariableDbId));
        if (locationDbId != null)
            localVarQueryParams.addAll(apiClient.parameterToPair("locationDbId", locationDbId));
        if (seasonDbId != null)
            localVarQueryParams.addAll(apiClient.parameterToPair("seasonDbId", seasonDbId));
        if (observationLevel != null)
            localVarQueryParams.addAll(apiClient.parameterToPair("observationLevel", observationLevel));
        if (searchResultsDbId != null)
            localVarQueryParams.addAll(apiClient.parameterToPair("searchResultsDbId", searchResultsDbId));
        if (observationTimeStampRangeStart != null)
            localVarQueryParams.addAll(apiClient.parameterToPair("observationTimeStampRangeStart", observationTimeStampRangeStart));
        if (observationTimeStampRangeEnd != null)
            localVarQueryParams.addAll(apiClient.parameterToPair("observationTimeStampRangeEnd", observationTimeStampRangeEnd));
        if (programDbId != null)
            localVarQueryParams.addAll(apiClient.parameterToPair("programDbId", programDbId));
        if (trialDbId != null)
            localVarQueryParams.addAll(apiClient.parameterToPair("trialDbId", trialDbId));
        if (studyDbId != null)
            localVarQueryParams.addAll(apiClient.parameterToPair("studyDbId", studyDbId));
        if (germplasmDbId != null)
            localVarQueryParams.addAll(apiClient.parameterToPair("germplasmDbId", germplasmDbId));
        if (observationUnitLevelName != null)
            localVarQueryParams.addAll(apiClient.parameterToPair("observationUnitLevelName", observationUnitLevelName));
        if (observationUnitLevelOrder != null)
            localVarQueryParams.addAll(apiClient.parameterToPair("observationUnitLevelOrder", observationUnitLevelOrder));
        if (observationUnitLevelCode != null)
            localVarQueryParams.addAll(apiClient.parameterToPair("observationUnitLevelCode", observationUnitLevelCode));
        if (observationUnitLevelRelationshipName != null)
            localVarQueryParams.addAll(apiClient.parameterToPair("observationUnitLevelRelationshipName", observationUnitLevelRelationshipName));
        if (observationUnitLevelRelationshipOrder != null)
            localVarQueryParams.addAll(apiClient.parameterToPair("observationUnitLevelRelationshipOrder", observationUnitLevelRelationshipOrder));
        if (observationUnitLevelRelationshipCode != null)
            localVarQueryParams.addAll(apiClient.parameterToPair("observationUnitLevelRelationshipCode", observationUnitLevelRelationshipCode));
        if (observationUnitLevelRelationshipDbId != null)
            localVarQueryParams.addAll(apiClient.parameterToPair("observationUnitLevelRelationshipDbId", observationUnitLevelRelationshipDbId));

        Map<String, String> localVarHeaderParams = new HashMap<>();
        if (accept != null)
            localVarHeaderParams.put("Accept", apiClient.parameterToString(accept));
        if (authorization != null)
            localVarHeaderParams.put("Authorization", apiClient.parameterToString(authorization));

        Map<String, Object> localVarFormParams = new HashMap<>();

        final String[] localVarAccepts = {
                "application/json", "text/csv", "text/tsv"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {

        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if (progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(chain -> {
                com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                return originalResponse.newBuilder()
                        .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                        .build();
            });
        }

        String[] localVarAuthNames = new String[]{"AuthorizationToken"};
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    private com.squareup.okhttp.Call observationsTableGetValidateBeforeCall(ContentTypes accept, String observationUnitDbId, String observationVariableDbId, String locationDbId, String seasonDbId, String observationLevel, String searchResultsDbId, OffsetDateTime observationTimeStampRangeStart, OffsetDateTime observationTimeStampRangeEnd, String programDbId, String trialDbId, String studyDbId, String germplasmDbId, String observationUnitLevelName, String observationUnitLevelOrder, String observationUnitLevelCode, String observationUnitLevelRelationshipName, String observationUnitLevelRelationshipOrder, String observationUnitLevelRelationshipCode, String observationUnitLevelRelationshipDbId, String authorization, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        // verify the required parameter 'accept' is set
        if (accept == null) {
            throw new ApiException("Missing the required parameter 'accept' when calling observationsTableGet(Async)");
        }

        return observationsTableGetCall(accept, observationUnitDbId, observationVariableDbId, locationDbId, seasonDbId, observationLevel, searchResultsDbId, observationTimeStampRangeStart, observationTimeStampRangeEnd, programDbId, trialDbId, studyDbId, germplasmDbId, observationUnitLevelName, observationUnitLevelOrder, observationUnitLevelCode, observationUnitLevelRelationshipName, observationUnitLevelRelationshipOrder, observationUnitLevelRelationshipCode, observationUnitLevelRelationshipDbId, authorization, progressListener, progressRequestListener);


    }

    /**
     * Get a list of Observations in a table format
     * &lt;p&gt;This service is designed to retrieve a table of time dependant observation values as a matrix of Observation Units and Observation Variables. This is also sometimes called a Time Series. This service takes the \&quot;Sparse Table\&quot; approach for representing this time dependant data.&lt;/p&gt; &lt;p&gt;The table may be represented by JSON, CSV, or TSV. The \&quot;Accept\&quot; HTTP header is used for the client to request different return formats.  By default, if the \&quot;Accept\&quot; header is not included in the request, the server should return JSON as described below.&lt;/p&gt; &lt;p&gt;The table is REQUIRED to have the following columns&lt;/p&gt; &lt;ul&gt;   &lt;li&gt;observationUnitDbId - Each row is related to one Observation Unit&lt;/li&gt;   &lt;li&gt;observationTimeStamp - Each row is has a time stamp for when the observation was taken&lt;/li&gt;   &lt;li&gt;At least one column with an observationVariableDbId&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;The table may have any or all of the following OPTIONAL columns. Included columns are decided by the server developer&lt;/p&gt; &lt;ul&gt;   &lt;li&gt;observationUnitName&lt;/li&gt;   &lt;li&gt;studyDbId&lt;/li&gt;   &lt;li&gt;studyName&lt;/li&gt;   &lt;li&gt;germplasmDbId&lt;/li&gt;   &lt;li&gt;germplasmName&lt;/li&gt;   &lt;li&gt;positionCoordinateX&lt;/li&gt;   &lt;li&gt;positionCoordinateY&lt;/li&gt;   &lt;li&gt;year&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;The table also may have any number of Observation Unit Hierarchy Level columns. For example:&lt;/p&gt; &lt;ul&gt;   &lt;li&gt;field&lt;/li&gt;   &lt;li&gt;plot&lt;/li&gt;   &lt;li&gt;sub-plot&lt;/li&gt;   &lt;li&gt;plant&lt;/li&gt;   &lt;li&gt;pot&lt;/li&gt;   &lt;li&gt;block&lt;/li&gt;   &lt;li&gt;entry&lt;/li&gt;   &lt;li&gt;rep&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;The JSON representation provides a pair of extra arrays for defining the headers of the table.  The first array \&quot;headerRow\&quot; will always contain \&quot;observationUnitDbId\&quot; and any or all of the OPTIONAL column header names.  The second array \&quot;observationVariables\&quot; contains the names and DbIds for the Observation Variables represented in the table.  By appending the two arrays, you can construct the complete header row of the table. &lt;/p&gt; &lt;p&gt;For CSV and TSV representations of the table, an extra header row is needed to describe both the Observation Variable DbId and the Observation Variable Name for each data column.  See the example responses below&lt;/p&gt;
     *
     * @param accept                                A standard HTTP request header that is used to request a specific content type (JSON, CSV, etc) which is \&quot;acceptable\&quot; to the client and should be returned by the server (required)
     * @param observationUnitDbId                   The unique ID of an Observation Unit (optional)
     * @param observationVariableDbId               The unique ID of an observation variable (optional)
     * @param locationDbId                          The unique ID of a location where these observations were collected (optional)
     * @param seasonDbId                            The year or Phenotyping campaign of a multi-annual study (trees, grape, ...) (optional)
     * @param observationLevel                      **Deprecated in v2.1** Please use &#x60;observationUnitLevelName&#x60;. Github issue number #464  &lt;br&gt;The type of the observationUnit. Returns only the observation unit of the specified type; the parent levels ID can be accessed through observationUnitStructure.  (optional)
     * @param searchResultsDbId                     Permanent unique identifier which references the search results (optional)
     * @param observationTimeStampRangeStart        Timestamp range start (optional)
     * @param observationTimeStampRangeEnd          Timestamp range end (optional)
     * @param programDbId                           Use this parameter to only return results associated with the given &#x60;Program&#x60; unique identifier.  &lt;br/&gt;Use &#x60;GET /programs&#x60; to find the list of available &#x60;Programs&#x60; on a server. (optional)
     * @param trialDbId                             Use this parameter to only return results associated with the given &#x60;Trial&#x60; unique identifier.  &lt;br/&gt;Use &#x60;GET /trials&#x60; to find the list of available &#x60;Trials&#x60; on a server. (optional)
     * @param studyDbId                             Use this parameter to only return results associated with the given &#x60;Study&#x60; unique identifier.  &lt;br/&gt;Use &#x60;GET /studies&#x60; to find the list of available &#x60;Studies&#x60; on a server. (optional)
     * @param germplasmDbId                         Use this parameter to only return results associated with the given &#x60;Germplasm&#x60; unique identifier.  &lt;br/&gt;Use &#x60;GET /germplasm&#x60; to find the list of available &#x60;Germplasm&#x60; on a server. (optional)
     * @param observationUnitLevelName              The Observation Unit Level. Returns only the observation unit of the specified Level.  &lt;br/&gt;References ObservationUnit-&gt;observationUnitPosition-&gt;observationLevel-&gt;levelName  &lt;br/&gt;**Standard Level Names: study, field, entry, rep, block, sub-block, plot, sub-plot, plant, pot, sample**  &lt;br/&gt;For more information on Observation Levels, please review the &lt;a target&#x3D;\&quot;_blank\&quot; href&#x3D;\&quot;https://wiki.brapi.org/index.php/Observation_Levels\&quot;&gt;Observation Levels documentation&lt;/a&gt;.  (optional)
     * @param observationUnitLevelOrder             The Observation Unit Level Order Number. Returns only the observation unit of the specified Level.  References ObservationUnit-&gt;observationUnitPosition-&gt;observationLevel-&gt;levelOrder  &lt;br/&gt;For more information on Observation Levels, please review the &lt;a target&#x3D;\&quot;_blank\&quot; href&#x3D;\&quot;https://wiki.brapi.org/index.php/Observation_Levels\&quot;&gt;Observation Levels documentation&lt;/a&gt;.  (optional)
     * @param observationUnitLevelCode              The Observation Unit Level Code. This parameter should be used together with &#x60;observationUnitLevelName&#x60;  or &#x60;observationUnitLevelOrder&#x60;. References ObservationUnit-&gt;observationUnitPosition-&gt;observationLevel-&gt;levelCode  &lt;br/&gt;For more information on Observation Levels, please review the &lt;a target&#x3D;\&quot;_blank\&quot; href&#x3D;\&quot;https://wiki.brapi.org/index.php/Observation_Levels\&quot;&gt;Observation Levels documentation&lt;/a&gt;.  (optional)
     * @param observationUnitLevelRelationshipName  The Observation Unit Level Relationship is a connection that this observation unit has to another level of the hierarchy.  &lt;br/&gt;For example, if you have several observation units at a &#x27;plot&#x27; level, they might all share a relationship to the same &#x27;field&#x27; level.   &lt;br/&gt;Use this parameter to identify groups of observation units that share a relationship level.  &lt;br/&gt;**Standard Level Names: study, field, entry, rep, block, sub-block, plot, sub-plot, plant, pot, sample**  &lt;br/&gt;For more information on Observation Levels, please review the &lt;a target&#x3D;\&quot;_blank\&quot; href&#x3D;\&quot;https://wiki.brapi.org/index.php/Observation_Levels\&quot;&gt;Observation Levels documentation&lt;/a&gt;.  (optional)
     * @param observationUnitLevelRelationshipOrder The Observation Unit Level Order Number.  &lt;br/&gt;Returns only the observation unit of the specified Level. References ObservationUnit-&gt;observationUnitPosition-&gt;observationLevel-&gt;levelOrder  &lt;br/&gt;For more information on Observation Levels, please review the &lt;a target&#x3D;\&quot;_blank\&quot; href&#x3D;\&quot;https://wiki.brapi.org/index.php/Observation_Levels\&quot;&gt;Observation Levels documentation&lt;/a&gt;.  (optional)
     * @param observationUnitLevelRelationshipCode  The Observation Unit Level Code.  &lt;br/&gt;This parameter should be used together with &#x60;observationUnitLevelName&#x60; or &#x60;observationUnitLevelOrder&#x60;. References ObservationUnit-&gt;observationUnitPosition-&gt;observationLevel-&gt;levelCode  &lt;br/&gt;For more information on Observation Levels, please review the &lt;a target&#x3D;\&quot;_blank\&quot; href&#x3D;\&quot;https://wiki.brapi.org/index.php/Observation_Levels\&quot;&gt;Observation Levels documentation&lt;/a&gt;.  (optional)
     * @param observationUnitLevelRelationshipDbId  The observationUnitDbId associated with a particular level and code. &lt;br/&gt;This parameter should be used together with &#x60;observationUnitLevelName&#x60; or &#x60;observationUnitLevelOrder&#x60;. References ObservationUnit-&gt;observationUnitPosition-&gt;observationLevel-&gt;observationUnitDbId  &lt;br/&gt;For more information on Observation Levels, please review the &lt;a target&#x3D;\&quot;_blank\&quot; href&#x3D;\&quot;https://wiki.brapi.org/index.php/Observation_Levels\&quot;&gt;Observation Levels documentation&lt;/a&gt;.  (optional)
     * @param authorization                         HTTP HEADER - Token used for Authorization   &lt;strong&gt; Bearer {token_string} &lt;/strong&gt; (optional)
     * @return ObservationTableResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ObservationTableResponse observationsTableGet(ContentTypes accept, String observationUnitDbId, String observationVariableDbId, String locationDbId, String seasonDbId, String observationLevel, String searchResultsDbId, OffsetDateTime observationTimeStampRangeStart, OffsetDateTime observationTimeStampRangeEnd, String programDbId, String trialDbId, String studyDbId, String germplasmDbId, String observationUnitLevelName, String observationUnitLevelOrder, String observationUnitLevelCode, String observationUnitLevelRelationshipName, String observationUnitLevelRelationshipOrder, String observationUnitLevelRelationshipCode, String observationUnitLevelRelationshipDbId, String authorization) throws ApiException {
        ApiResponse<ObservationTableResponse> resp = observationsTableGetWithHttpInfo(accept, observationUnitDbId, observationVariableDbId, locationDbId, seasonDbId, observationLevel, searchResultsDbId, observationTimeStampRangeStart, observationTimeStampRangeEnd, programDbId, trialDbId, studyDbId, germplasmDbId, observationUnitLevelName, observationUnitLevelOrder, observationUnitLevelCode, observationUnitLevelRelationshipName, observationUnitLevelRelationshipOrder, observationUnitLevelRelationshipCode, observationUnitLevelRelationshipDbId, authorization);
        return resp.getData();
    }

    /**
     * Get a list of Observations in a table format
     * &lt;p&gt;This service is designed to retrieve a table of time dependant observation values as a matrix of Observation Units and Observation Variables. This is also sometimes called a Time Series. This service takes the \&quot;Sparse Table\&quot; approach for representing this time dependant data.&lt;/p&gt; &lt;p&gt;The table may be represented by JSON, CSV, or TSV. The \&quot;Accept\&quot; HTTP header is used for the client to request different return formats.  By default, if the \&quot;Accept\&quot; header is not included in the request, the server should return JSON as described below.&lt;/p&gt; &lt;p&gt;The table is REQUIRED to have the following columns&lt;/p&gt; &lt;ul&gt;   &lt;li&gt;observationUnitDbId - Each row is related to one Observation Unit&lt;/li&gt;   &lt;li&gt;observationTimeStamp - Each row is has a time stamp for when the observation was taken&lt;/li&gt;   &lt;li&gt;At least one column with an observationVariableDbId&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;The table may have any or all of the following OPTIONAL columns. Included columns are decided by the server developer&lt;/p&gt; &lt;ul&gt;   &lt;li&gt;observationUnitName&lt;/li&gt;   &lt;li&gt;studyDbId&lt;/li&gt;   &lt;li&gt;studyName&lt;/li&gt;   &lt;li&gt;germplasmDbId&lt;/li&gt;   &lt;li&gt;germplasmName&lt;/li&gt;   &lt;li&gt;positionCoordinateX&lt;/li&gt;   &lt;li&gt;positionCoordinateY&lt;/li&gt;   &lt;li&gt;year&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;The table also may have any number of Observation Unit Hierarchy Level columns. For example:&lt;/p&gt; &lt;ul&gt;   &lt;li&gt;field&lt;/li&gt;   &lt;li&gt;plot&lt;/li&gt;   &lt;li&gt;sub-plot&lt;/li&gt;   &lt;li&gt;plant&lt;/li&gt;   &lt;li&gt;pot&lt;/li&gt;   &lt;li&gt;block&lt;/li&gt;   &lt;li&gt;entry&lt;/li&gt;   &lt;li&gt;rep&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;The JSON representation provides a pair of extra arrays for defining the headers of the table.  The first array \&quot;headerRow\&quot; will always contain \&quot;observationUnitDbId\&quot; and any or all of the OPTIONAL column header names.  The second array \&quot;observationVariables\&quot; contains the names and DbIds for the Observation Variables represented in the table.  By appending the two arrays, you can construct the complete header row of the table. &lt;/p&gt; &lt;p&gt;For CSV and TSV representations of the table, an extra header row is needed to describe both the Observation Variable DbId and the Observation Variable Name for each data column.  See the example responses below&lt;/p&gt;
     *
     * @param accept                                A standard HTTP request header that is used to request a specific content type (JSON, CSV, etc) which is \&quot;acceptable\&quot; to the client and should be returned by the server (required)
     * @param observationUnitDbId                   The unique ID of an Observation Unit (optional)
     * @param observationVariableDbId               The unique ID of an observation variable (optional)
     * @param locationDbId                          The unique ID of a location where these observations were collected (optional)
     * @param seasonDbId                            The year or Phenotyping campaign of a multi-annual study (trees, grape, ...) (optional)
     * @param observationLevel                      **Deprecated in v2.1** Please use &#x60;observationUnitLevelName&#x60;. Github issue number #464  &lt;br&gt;The type of the observationUnit. Returns only the observation unit of the specified type; the parent levels ID can be accessed through observationUnitStructure.  (optional)
     * @param searchResultsDbId                     Permanent unique identifier which references the search results (optional)
     * @param observationTimeStampRangeStart        Timestamp range start (optional)
     * @param observationTimeStampRangeEnd          Timestamp range end (optional)
     * @param programDbId                           Use this parameter to only return results associated with the given &#x60;Program&#x60; unique identifier.  &lt;br/&gt;Use &#x60;GET /programs&#x60; to find the list of available &#x60;Programs&#x60; on a server. (optional)
     * @param trialDbId                             Use this parameter to only return results associated with the given &#x60;Trial&#x60; unique identifier.  &lt;br/&gt;Use &#x60;GET /trials&#x60; to find the list of available &#x60;Trials&#x60; on a server. (optional)
     * @param studyDbId                             Use this parameter to only return results associated with the given &#x60;Study&#x60; unique identifier.  &lt;br/&gt;Use &#x60;GET /studies&#x60; to find the list of available &#x60;Studies&#x60; on a server. (optional)
     * @param germplasmDbId                         Use this parameter to only return results associated with the given &#x60;Germplasm&#x60; unique identifier.  &lt;br/&gt;Use &#x60;GET /germplasm&#x60; to find the list of available &#x60;Germplasm&#x60; on a server. (optional)
     * @param observationUnitLevelName              The Observation Unit Level. Returns only the observation unit of the specified Level.  &lt;br/&gt;References ObservationUnit-&gt;observationUnitPosition-&gt;observationLevel-&gt;levelName  &lt;br/&gt;**Standard Level Names: study, field, entry, rep, block, sub-block, plot, sub-plot, plant, pot, sample**  &lt;br/&gt;For more information on Observation Levels, please review the &lt;a target&#x3D;\&quot;_blank\&quot; href&#x3D;\&quot;https://wiki.brapi.org/index.php/Observation_Levels\&quot;&gt;Observation Levels documentation&lt;/a&gt;.  (optional)
     * @param observationUnitLevelOrder             The Observation Unit Level Order Number. Returns only the observation unit of the specified Level.  References ObservationUnit-&gt;observationUnitPosition-&gt;observationLevel-&gt;levelOrder  &lt;br/&gt;For more information on Observation Levels, please review the &lt;a target&#x3D;\&quot;_blank\&quot; href&#x3D;\&quot;https://wiki.brapi.org/index.php/Observation_Levels\&quot;&gt;Observation Levels documentation&lt;/a&gt;.  (optional)
     * @param observationUnitLevelCode              The Observation Unit Level Code. This parameter should be used together with &#x60;observationUnitLevelName&#x60;  or &#x60;observationUnitLevelOrder&#x60;. References ObservationUnit-&gt;observationUnitPosition-&gt;observationLevel-&gt;levelCode  &lt;br/&gt;For more information on Observation Levels, please review the &lt;a target&#x3D;\&quot;_blank\&quot; href&#x3D;\&quot;https://wiki.brapi.org/index.php/Observation_Levels\&quot;&gt;Observation Levels documentation&lt;/a&gt;.  (optional)
     * @param observationUnitLevelRelationshipName  The Observation Unit Level Relationship is a connection that this observation unit has to another level of the hierarchy.  &lt;br/&gt;For example, if you have several observation units at a &#x27;plot&#x27; level, they might all share a relationship to the same &#x27;field&#x27; level.   &lt;br/&gt;Use this parameter to identify groups of observation units that share a relationship level.  &lt;br/&gt;**Standard Level Names: study, field, entry, rep, block, sub-block, plot, sub-plot, plant, pot, sample**  &lt;br/&gt;For more information on Observation Levels, please review the &lt;a target&#x3D;\&quot;_blank\&quot; href&#x3D;\&quot;https://wiki.brapi.org/index.php/Observation_Levels\&quot;&gt;Observation Levels documentation&lt;/a&gt;.  (optional)
     * @param observationUnitLevelRelationshipOrder The Observation Unit Level Order Number.  &lt;br/&gt;Returns only the observation unit of the specified Level. References ObservationUnit-&gt;observationUnitPosition-&gt;observationLevel-&gt;levelOrder  &lt;br/&gt;For more information on Observation Levels, please review the &lt;a target&#x3D;\&quot;_blank\&quot; href&#x3D;\&quot;https://wiki.brapi.org/index.php/Observation_Levels\&quot;&gt;Observation Levels documentation&lt;/a&gt;.  (optional)
     * @param observationUnitLevelRelationshipCode  The Observation Unit Level Code.  &lt;br/&gt;This parameter should be used together with &#x60;observationUnitLevelName&#x60; or &#x60;observationUnitLevelOrder&#x60;. References ObservationUnit-&gt;observationUnitPosition-&gt;observationLevel-&gt;levelCode  &lt;br/&gt;For more information on Observation Levels, please review the &lt;a target&#x3D;\&quot;_blank\&quot; href&#x3D;\&quot;https://wiki.brapi.org/index.php/Observation_Levels\&quot;&gt;Observation Levels documentation&lt;/a&gt;.  (optional)
     * @param observationUnitLevelRelationshipDbId  The observationUnitDbId associated with a particular level and code. &lt;br/&gt;This parameter should be used together with &#x60;observationUnitLevelName&#x60; or &#x60;observationUnitLevelOrder&#x60;. References ObservationUnit-&gt;observationUnitPosition-&gt;observationLevel-&gt;observationUnitDbId  &lt;br/&gt;For more information on Observation Levels, please review the &lt;a target&#x3D;\&quot;_blank\&quot; href&#x3D;\&quot;https://wiki.brapi.org/index.php/Observation_Levels\&quot;&gt;Observation Levels documentation&lt;/a&gt;.  (optional)
     * @param authorization                         HTTP HEADER - Token used for Authorization   &lt;strong&gt; Bearer {token_string} &lt;/strong&gt; (optional)
     * @return ApiResponse&lt;ObservationTableResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<ObservationTableResponse> observationsTableGetWithHttpInfo(ContentTypes accept, String observationUnitDbId, String observationVariableDbId, String locationDbId, String seasonDbId, String observationLevel, String searchResultsDbId, OffsetDateTime observationTimeStampRangeStart, OffsetDateTime observationTimeStampRangeEnd, String programDbId, String trialDbId, String studyDbId, String germplasmDbId, String observationUnitLevelName, String observationUnitLevelOrder, String observationUnitLevelCode, String observationUnitLevelRelationshipName, String observationUnitLevelRelationshipOrder, String observationUnitLevelRelationshipCode, String observationUnitLevelRelationshipDbId, String authorization) throws ApiException {
        com.squareup.okhttp.Call call = observationsTableGetValidateBeforeCall(accept, observationUnitDbId, observationVariableDbId, locationDbId, seasonDbId, observationLevel, searchResultsDbId, observationTimeStampRangeStart, observationTimeStampRangeEnd, programDbId, trialDbId, studyDbId, germplasmDbId, observationUnitLevelName, observationUnitLevelOrder, observationUnitLevelCode, observationUnitLevelRelationshipName, observationUnitLevelRelationshipOrder, observationUnitLevelRelationshipCode, observationUnitLevelRelationshipDbId, authorization, null, null);
        Type localVarReturnType = new TypeToken<ObservationTableResponse>() {
        }.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Get a list of Observations in a table format (asynchronously)
     * &lt;p&gt;This service is designed to retrieve a table of time dependant observation values as a matrix of Observation Units and Observation Variables. This is also sometimes called a Time Series. This service takes the \&quot;Sparse Table\&quot; approach for representing this time dependant data.&lt;/p&gt; &lt;p&gt;The table may be represented by JSON, CSV, or TSV. The \&quot;Accept\&quot; HTTP header is used for the client to request different return formats.  By default, if the \&quot;Accept\&quot; header is not included in the request, the server should return JSON as described below.&lt;/p&gt; &lt;p&gt;The table is REQUIRED to have the following columns&lt;/p&gt; &lt;ul&gt;   &lt;li&gt;observationUnitDbId - Each row is related to one Observation Unit&lt;/li&gt;   &lt;li&gt;observationTimeStamp - Each row is has a time stamp for when the observation was taken&lt;/li&gt;   &lt;li&gt;At least one column with an observationVariableDbId&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;The table may have any or all of the following OPTIONAL columns. Included columns are decided by the server developer&lt;/p&gt; &lt;ul&gt;   &lt;li&gt;observationUnitName&lt;/li&gt;   &lt;li&gt;studyDbId&lt;/li&gt;   &lt;li&gt;studyName&lt;/li&gt;   &lt;li&gt;germplasmDbId&lt;/li&gt;   &lt;li&gt;germplasmName&lt;/li&gt;   &lt;li&gt;positionCoordinateX&lt;/li&gt;   &lt;li&gt;positionCoordinateY&lt;/li&gt;   &lt;li&gt;year&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;The table also may have any number of Observation Unit Hierarchy Level columns. For example:&lt;/p&gt; &lt;ul&gt;   &lt;li&gt;field&lt;/li&gt;   &lt;li&gt;plot&lt;/li&gt;   &lt;li&gt;sub-plot&lt;/li&gt;   &lt;li&gt;plant&lt;/li&gt;   &lt;li&gt;pot&lt;/li&gt;   &lt;li&gt;block&lt;/li&gt;   &lt;li&gt;entry&lt;/li&gt;   &lt;li&gt;rep&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;The JSON representation provides a pair of extra arrays for defining the headers of the table.  The first array \&quot;headerRow\&quot; will always contain \&quot;observationUnitDbId\&quot; and any or all of the OPTIONAL column header names.  The second array \&quot;observationVariables\&quot; contains the names and DbIds for the Observation Variables represented in the table.  By appending the two arrays, you can construct the complete header row of the table. &lt;/p&gt; &lt;p&gt;For CSV and TSV representations of the table, an extra header row is needed to describe both the Observation Variable DbId and the Observation Variable Name for each data column.  See the example responses below&lt;/p&gt;
     *
     * @param accept                                A standard HTTP request header that is used to request a specific content type (JSON, CSV, etc) which is \&quot;acceptable\&quot; to the client and should be returned by the server (required)
     * @param observationUnitDbId                   The unique ID of an Observation Unit (optional)
     * @param observationVariableDbId               The unique ID of an observation variable (optional)
     * @param locationDbId                          The unique ID of a location where these observations were collected (optional)
     * @param seasonDbId                            The year or Phenotyping campaign of a multi-annual study (trees, grape, ...) (optional)
     * @param observationLevel                      **Deprecated in v2.1** Please use &#x60;observationUnitLevelName&#x60;. Github issue number #464  &lt;br&gt;The type of the observationUnit. Returns only the observation unit of the specified type; the parent levels ID can be accessed through observationUnitStructure.  (optional)
     * @param searchResultsDbId                     Permanent unique identifier which references the search results (optional)
     * @param observationTimeStampRangeStart        Timestamp range start (optional)
     * @param observationTimeStampRangeEnd          Timestamp range end (optional)
     * @param programDbId                           Use this parameter to only return results associated with the given &#x60;Program&#x60; unique identifier.  &lt;br/&gt;Use &#x60;GET /programs&#x60; to find the list of available &#x60;Programs&#x60; on a server. (optional)
     * @param trialDbId                             Use this parameter to only return results associated with the given &#x60;Trial&#x60; unique identifier.  &lt;br/&gt;Use &#x60;GET /trials&#x60; to find the list of available &#x60;Trials&#x60; on a server. (optional)
     * @param studyDbId                             Use this parameter to only return results associated with the given &#x60;Study&#x60; unique identifier.  &lt;br/&gt;Use &#x60;GET /studies&#x60; to find the list of available &#x60;Studies&#x60; on a server. (optional)
     * @param germplasmDbId                         Use this parameter to only return results associated with the given &#x60;Germplasm&#x60; unique identifier.  &lt;br/&gt;Use &#x60;GET /germplasm&#x60; to find the list of available &#x60;Germplasm&#x60; on a server. (optional)
     * @param observationUnitLevelName              The Observation Unit Level. Returns only the observation unit of the specified Level.  &lt;br/&gt;References ObservationUnit-&gt;observationUnitPosition-&gt;observationLevel-&gt;levelName  &lt;br/&gt;**Standard Level Names: study, field, entry, rep, block, sub-block, plot, sub-plot, plant, pot, sample**  &lt;br/&gt;For more information on Observation Levels, please review the &lt;a target&#x3D;\&quot;_blank\&quot; href&#x3D;\&quot;https://wiki.brapi.org/index.php/Observation_Levels\&quot;&gt;Observation Levels documentation&lt;/a&gt;.  (optional)
     * @param observationUnitLevelOrder             The Observation Unit Level Order Number. Returns only the observation unit of the specified Level.  References ObservationUnit-&gt;observationUnitPosition-&gt;observationLevel-&gt;levelOrder  &lt;br/&gt;For more information on Observation Levels, please review the &lt;a target&#x3D;\&quot;_blank\&quot; href&#x3D;\&quot;https://wiki.brapi.org/index.php/Observation_Levels\&quot;&gt;Observation Levels documentation&lt;/a&gt;.  (optional)
     * @param observationUnitLevelCode              The Observation Unit Level Code. This parameter should be used together with &#x60;observationUnitLevelName&#x60;  or &#x60;observationUnitLevelOrder&#x60;. References ObservationUnit-&gt;observationUnitPosition-&gt;observationLevel-&gt;levelCode  &lt;br/&gt;For more information on Observation Levels, please review the &lt;a target&#x3D;\&quot;_blank\&quot; href&#x3D;\&quot;https://wiki.brapi.org/index.php/Observation_Levels\&quot;&gt;Observation Levels documentation&lt;/a&gt;.  (optional)
     * @param observationUnitLevelRelationshipName  The Observation Unit Level Relationship is a connection that this observation unit has to another level of the hierarchy.  &lt;br/&gt;For example, if you have several observation units at a &#x27;plot&#x27; level, they might all share a relationship to the same &#x27;field&#x27; level.   &lt;br/&gt;Use this parameter to identify groups of observation units that share a relationship level.  &lt;br/&gt;**Standard Level Names: study, field, entry, rep, block, sub-block, plot, sub-plot, plant, pot, sample**  &lt;br/&gt;For more information on Observation Levels, please review the &lt;a target&#x3D;\&quot;_blank\&quot; href&#x3D;\&quot;https://wiki.brapi.org/index.php/Observation_Levels\&quot;&gt;Observation Levels documentation&lt;/a&gt;.  (optional)
     * @param observationUnitLevelRelationshipOrder The Observation Unit Level Order Number.  &lt;br/&gt;Returns only the observation unit of the specified Level. References ObservationUnit-&gt;observationUnitPosition-&gt;observationLevel-&gt;levelOrder  &lt;br/&gt;For more information on Observation Levels, please review the &lt;a target&#x3D;\&quot;_blank\&quot; href&#x3D;\&quot;https://wiki.brapi.org/index.php/Observation_Levels\&quot;&gt;Observation Levels documentation&lt;/a&gt;.  (optional)
     * @param observationUnitLevelRelationshipCode  The Observation Unit Level Code.  &lt;br/&gt;This parameter should be used together with &#x60;observationUnitLevelName&#x60; or &#x60;observationUnitLevelOrder&#x60;. References ObservationUnit-&gt;observationUnitPosition-&gt;observationLevel-&gt;levelCode  &lt;br/&gt;For more information on Observation Levels, please review the &lt;a target&#x3D;\&quot;_blank\&quot; href&#x3D;\&quot;https://wiki.brapi.org/index.php/Observation_Levels\&quot;&gt;Observation Levels documentation&lt;/a&gt;.  (optional)
     * @param observationUnitLevelRelationshipDbId  The observationUnitDbId associated with a particular level and code. &lt;br/&gt;This parameter should be used together with &#x60;observationUnitLevelName&#x60; or &#x60;observationUnitLevelOrder&#x60;. References ObservationUnit-&gt;observationUnitPosition-&gt;observationLevel-&gt;observationUnitDbId  &lt;br/&gt;For more information on Observation Levels, please review the &lt;a target&#x3D;\&quot;_blank\&quot; href&#x3D;\&quot;https://wiki.brapi.org/index.php/Observation_Levels\&quot;&gt;Observation Levels documentation&lt;/a&gt;.  (optional)
     * @param authorization                         HTTP HEADER - Token used for Authorization   &lt;strong&gt; Bearer {token_string} &lt;/strong&gt; (optional)
     * @param callback                              The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call observationsTableGetAsync(ContentTypes accept, String observationUnitDbId, String observationVariableDbId, String locationDbId, String seasonDbId, String observationLevel, String searchResultsDbId, OffsetDateTime observationTimeStampRangeStart, OffsetDateTime observationTimeStampRangeEnd, String programDbId, String trialDbId, String studyDbId, String germplasmDbId, String observationUnitLevelName, String observationUnitLevelOrder, String observationUnitLevelCode, String observationUnitLevelRelationshipName, String observationUnitLevelRelationshipOrder, String observationUnitLevelRelationshipCode, String observationUnitLevelRelationshipDbId, String authorization, final ApiCallback<ObservationTableResponse> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = callback::onDownloadProgress;

            progressRequestListener = callback::onUploadProgress;
        }

        com.squareup.okhttp.Call call = observationsTableGetValidateBeforeCall(accept, observationUnitDbId, observationVariableDbId, locationDbId, seasonDbId, observationLevel, searchResultsDbId, observationTimeStampRangeStart, observationTimeStampRangeEnd, programDbId, trialDbId, studyDbId, germplasmDbId, observationUnitLevelName, observationUnitLevelOrder, observationUnitLevelCode, observationUnitLevelRelationshipName, observationUnitLevelRelationshipOrder, observationUnitLevelRelationshipCode, observationUnitLevelRelationshipDbId, authorization, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<ObservationTableResponse>() {
        }.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }

    /**
     * Build call for searchObservationsPost
     *
     * @param body                    (optional)
     * @param authorization           HTTP HEADER - Token used for Authorization   &lt;strong&gt; Bearer {token_string} &lt;/strong&gt; (optional)
     * @param progressListener        Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call searchObservationsPostCall(SearchObservationsBody body, String authorization, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {

        // create path and map variables
        String localVarPath = "/search/observations";

        List<Pair> localVarQueryParams = new ArrayList<>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<>();

        Map<String, String> localVarHeaderParams = new HashMap<>();
        if (authorization != null)
            localVarHeaderParams.put("Authorization", apiClient.parameterToString(authorization));

        Map<String, Object> localVarFormParams = new HashMap<>();

        final String[] localVarAccepts = {
                "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
                "application/json"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if (progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(chain -> {
                com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                return originalResponse.newBuilder()
                        .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                        .build();
            });
        }

        String[] localVarAuthNames = new String[]{"AuthorizationToken"};
        return apiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, body, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    private com.squareup.okhttp.Call searchObservationsPostValidateBeforeCall(SearchObservationsBody body, String authorization, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {

        return searchObservationsPostCall(body, authorization, progressListener, progressRequestListener);


    }

    /**
     * Submit a search request for &#x60;Observations&#x60;
     * Submit a search request for &#x60;Observations&#x60;&lt;br/&gt; Search requests allow a client to send a complex query for data. However, the server may not respond with the search results immediately.  If a server needs more time to process the request, it might respond with a &#x60;searchResultsDbId&#x60;.  Use the corresponding &#x60;GET /search/observations/{searchResultsDbId}&#x60; to retrieve the results of the search. &lt;br/&gt;  Review the &lt;a target&#x3D;\&quot;_blank\&quot; href&#x3D;\&quot;https://wiki.brapi.org/index.php/Search_Services#POST_Search_Entity\&quot;&gt;Search Services documentation&lt;/a&gt; for additional implementation details.
     *
     * @param body          (optional)
     * @param authorization HTTP HEADER - Token used for Authorization   &lt;strong&gt; Bearer {token_string} &lt;/strong&gt; (optional)
     * @return ObservationListResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ObservationListResponse searchObservationsPost(SearchObservationsBody body, String authorization) throws ApiException {
        ApiResponse<ObservationListResponse> resp = searchObservationsPostWithHttpInfo(body, authorization);
        return resp.getData();
    }

    /**
     * Submit a search request for &#x60;Observations&#x60;
     * Submit a search request for &#x60;Observations&#x60;&lt;br/&gt; Search requests allow a client to send a complex query for data. However, the server may not respond with the search results immediately.  If a server needs more time to process the request, it might respond with a &#x60;searchResultsDbId&#x60;.  Use the corresponding &#x60;GET /search/observations/{searchResultsDbId}&#x60; to retrieve the results of the search. &lt;br/&gt;  Review the &lt;a target&#x3D;\&quot;_blank\&quot; href&#x3D;\&quot;https://wiki.brapi.org/index.php/Search_Services#POST_Search_Entity\&quot;&gt;Search Services documentation&lt;/a&gt; for additional implementation details.
     *
     * @param body          (optional)
     * @param authorization HTTP HEADER - Token used for Authorization   &lt;strong&gt; Bearer {token_string} &lt;/strong&gt; (optional)
     * @return ApiResponse&lt;ObservationListResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<ObservationListResponse> searchObservationsPostWithHttpInfo(SearchObservationsBody body, String authorization) throws ApiException {
        com.squareup.okhttp.Call call = searchObservationsPostValidateBeforeCall(body, authorization, null, null);
        Type localVarReturnType = new TypeToken<ObservationListResponse>() {
        }.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Submit a search request for &#x60;Observations&#x60; (asynchronously)
     * Submit a search request for &#x60;Observations&#x60;&lt;br/&gt; Search requests allow a client to send a complex query for data. However, the server may not respond with the search results immediately.  If a server needs more time to process the request, it might respond with a &#x60;searchResultsDbId&#x60;.  Use the corresponding &#x60;GET /search/observations/{searchResultsDbId}&#x60; to retrieve the results of the search. &lt;br/&gt;  Review the &lt;a target&#x3D;\&quot;_blank\&quot; href&#x3D;\&quot;https://wiki.brapi.org/index.php/Search_Services#POST_Search_Entity\&quot;&gt;Search Services documentation&lt;/a&gt; for additional implementation details.
     *
     * @param body          (optional)
     * @param authorization HTTP HEADER - Token used for Authorization   &lt;strong&gt; Bearer {token_string} &lt;/strong&gt; (optional)
     * @param callback      The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call searchObservationsPostAsync(SearchObservationsBody body, String authorization, final ApiCallback<ObservationListResponse> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = callback::onDownloadProgress;

            progressRequestListener = callback::onUploadProgress;
        }

        com.squareup.okhttp.Call call = searchObservationsPostValidateBeforeCall(body, authorization, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<ObservationListResponse>() {
        }.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }

    /**
     * Build call for searchObservationsSearchResultsDbIdGet
     *
     * @param accept                  A standard HTTP request header that is used to request a specific content type (JSON, CSV, etc) which is \&quot;acceptable\&quot; to the client and should be returned by the server (required)
     * @param searchResultsDbId       Unique identifier which references the search results (required)
     * @param authorization           HTTP HEADER - Token used for Authorization   &lt;strong&gt; Bearer {token_string} &lt;/strong&gt; (optional)
     * @param page                    Used to request a specific page of data to be returned.  The page indexing starts at 0 (the first page is &#x27;page&#x27;&#x3D; 0). Default is &#x60;0&#x60;. (optional)
     * @param pageSize                The size of the pages to be returned. Default is &#x60;1000&#x60;. (optional)
     * @param progressListener        Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call searchObservationsSearchResultsDbIdGetCall(ContentTypes accept, String searchResultsDbId, String authorization, Integer page, Integer pageSize, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/search/observations/{searchResultsDbId}"
                .replaceAll("\\{" + "searchResultsDbId" + "}", apiClient.escapeString(searchResultsDbId));

        List<Pair> localVarQueryParams = new ArrayList<>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<>();
        if (page != null)
            localVarQueryParams.addAll(apiClient.parameterToPair("page", page));
        if (pageSize != null)
            localVarQueryParams.addAll(apiClient.parameterToPair("pageSize", pageSize));

        Map<String, String> localVarHeaderParams = new HashMap<>();
        if (accept != null)
            localVarHeaderParams.put("Accept", apiClient.parameterToString(accept));
        if (authorization != null)
            localVarHeaderParams.put("Authorization", apiClient.parameterToString(authorization));

        Map<String, Object> localVarFormParams = new HashMap<>();

        final String[] localVarAccepts = {
                "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {

        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if (progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(chain -> {
                com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                return originalResponse.newBuilder()
                        .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                        .build();
            });
        }

        String[] localVarAuthNames = new String[]{"AuthorizationToken"};
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    private com.squareup.okhttp.Call searchObservationsSearchResultsDbIdGetValidateBeforeCall(ContentTypes accept, String searchResultsDbId, String authorization, Integer page, Integer pageSize, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        // verify the required parameter 'accept' is set
        if (accept == null) {
            throw new ApiException("Missing the required parameter 'accept' when calling searchObservationsSearchResultsDbIdGet(Async)");
        }
        // verify the required parameter 'searchResultsDbId' is set
        if (searchResultsDbId == null) {
            throw new ApiException("Missing the required parameter 'searchResultsDbId' when calling searchObservationsSearchResultsDbIdGet(Async)");
        }

        return searchObservationsSearchResultsDbIdGetCall(accept, searchResultsDbId, authorization, page, pageSize, progressListener, progressRequestListener);


    }

    /**
     * Get the results of a &#x60;Observations&#x60; search request
     * Get the results of a &#x60;Observations&#x60; search request &lt;br/&gt; Clients should submit a search request using the corresponding &#x60;POST /search/observations&#x60; endpoint. Search requests allow a client to send a complex query for data. However, the server may not respond with the search results immediately.  If a server needs more time to process the request, it might respond with a &#x60;searchResultsDbId&#x60;.  Use this endpoint to retrieve the results of the search. &lt;br/&gt;  Review the &lt;a target&#x3D;\&quot;_blank\&quot; href&#x3D;\&quot;https://wiki.brapi.org/index.php/Search_Services#POST_Search_Entity\&quot;&gt;Search Services documentation&lt;/a&gt; for additional implementation details.
     *
     * @param accept            A standard HTTP request header that is used to request a specific content type (JSON, CSV, etc) which is \&quot;acceptable\&quot; to the client and should be returned by the server (required)
     * @param searchResultsDbId Unique identifier which references the search results (required)
     * @param authorization     HTTP HEADER - Token used for Authorization   &lt;strong&gt; Bearer {token_string} &lt;/strong&gt; (optional)
     * @param page              Used to request a specific page of data to be returned.  The page indexing starts at 0 (the first page is &#x27;page&#x27;&#x3D; 0). Default is &#x60;0&#x60;. (optional)
     * @param pageSize          The size of the pages to be returned. Default is &#x60;1000&#x60;. (optional)
     * @return ObservationListResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ObservationListResponse searchObservationsSearchResultsDbIdGet(ContentTypes accept, String searchResultsDbId, String authorization, Integer page, Integer pageSize) throws ApiException {
        ApiResponse<ObservationListResponse> resp = searchObservationsSearchResultsDbIdGetWithHttpInfo(accept, searchResultsDbId, authorization, page, pageSize);
        return resp.getData();
    }

    /**
     * Get the results of a &#x60;Observations&#x60; search request
     * Get the results of a &#x60;Observations&#x60; search request &lt;br/&gt; Clients should submit a search request using the corresponding &#x60;POST /search/observations&#x60; endpoint. Search requests allow a client to send a complex query for data. However, the server may not respond with the search results immediately.  If a server needs more time to process the request, it might respond with a &#x60;searchResultsDbId&#x60;.  Use this endpoint to retrieve the results of the search. &lt;br/&gt;  Review the &lt;a target&#x3D;\&quot;_blank\&quot; href&#x3D;\&quot;https://wiki.brapi.org/index.php/Search_Services#POST_Search_Entity\&quot;&gt;Search Services documentation&lt;/a&gt; for additional implementation details.
     *
     * @param accept            A standard HTTP request header that is used to request a specific content type (JSON, CSV, etc) which is \&quot;acceptable\&quot; to the client and should be returned by the server (required)
     * @param searchResultsDbId Unique identifier which references the search results (required)
     * @param authorization     HTTP HEADER - Token used for Authorization   &lt;strong&gt; Bearer {token_string} &lt;/strong&gt; (optional)
     * @param page              Used to request a specific page of data to be returned.  The page indexing starts at 0 (the first page is &#x27;page&#x27;&#x3D; 0). Default is &#x60;0&#x60;. (optional)
     * @param pageSize          The size of the pages to be returned. Default is &#x60;1000&#x60;. (optional)
     * @return ApiResponse&lt;ObservationListResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<ObservationListResponse> searchObservationsSearchResultsDbIdGetWithHttpInfo(ContentTypes accept, String searchResultsDbId, String authorization, Integer page, Integer pageSize) throws ApiException {
        com.squareup.okhttp.Call call = searchObservationsSearchResultsDbIdGetValidateBeforeCall(accept, searchResultsDbId, authorization, page, pageSize, null, null);
        Type localVarReturnType = new TypeToken<ObservationListResponse>() {
        }.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Get the results of a &#x60;Observations&#x60; search request (asynchronously)
     * Get the results of a &#x60;Observations&#x60; search request &lt;br/&gt; Clients should submit a search request using the corresponding &#x60;POST /search/observations&#x60; endpoint. Search requests allow a client to send a complex query for data. However, the server may not respond with the search results immediately.  If a server needs more time to process the request, it might respond with a &#x60;searchResultsDbId&#x60;.  Use this endpoint to retrieve the results of the search. &lt;br/&gt;  Review the &lt;a target&#x3D;\&quot;_blank\&quot; href&#x3D;\&quot;https://wiki.brapi.org/index.php/Search_Services#POST_Search_Entity\&quot;&gt;Search Services documentation&lt;/a&gt; for additional implementation details.
     *
     * @param accept            A standard HTTP request header that is used to request a specific content type (JSON, CSV, etc) which is \&quot;acceptable\&quot; to the client and should be returned by the server (required)
     * @param searchResultsDbId Unique identifier which references the search results (required)
     * @param authorization     HTTP HEADER - Token used for Authorization   &lt;strong&gt; Bearer {token_string} &lt;/strong&gt; (optional)
     * @param page              Used to request a specific page of data to be returned.  The page indexing starts at 0 (the first page is &#x27;page&#x27;&#x3D; 0). Default is &#x60;0&#x60;. (optional)
     * @param pageSize          The size of the pages to be returned. Default is &#x60;1000&#x60;. (optional)
     * @param callback          The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call searchObservationsSearchResultsDbIdGetAsync(ContentTypes accept, String searchResultsDbId, String authorization, Integer page, Integer pageSize, final ApiCallback<ObservationListResponse> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = callback::onDownloadProgress;

            progressRequestListener = callback::onUploadProgress;
        }

        com.squareup.okhttp.Call call = searchObservationsSearchResultsDbIdGetValidateBeforeCall(accept, searchResultsDbId, authorization, page, pageSize, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<ObservationListResponse>() {
        }.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
}
