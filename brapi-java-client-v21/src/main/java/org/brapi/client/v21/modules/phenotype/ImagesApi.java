/*
 * BrAPI-Phenotyping
 * The Breeding API (BrAPI) is a Standardized REST ful Web Service API Specification for communicating Plant Breeding Data. BrAPI allows for easy data sharing between databases and tools involved in plant breeding. <div class=\"brapi-section\"> <h2 class=\"brapi-section-title\">General Reference Documentation</h2> <div class=\"gen-info-link\"><a href=\"https://wiki.brapi.org/index.php/RESTfulness\">URL Structure</a></div> <div class=\"gen-info-link\"><a href=\"https://wiki.brapi.org/index.php/Response_Structure\">Response Structure</a></div> <div class=\"gen-info-link\"><a href=\"https://wiki.brapi.org/index.php/Dates_and_Times\">Date/Time Encoding</a></div> <div class=\"gen-info-link\"><a href=\"https://wiki.brapi.org/index.php/Location_Coordinates\">Location Encoding</a></div> <div class=\"gen-info-link\"><a href=\"https://wiki.brapi.org/index.php/Error_Handling\">Error Handling</a></div> <div class=\"gen-info-link\"><a href=\"https://wiki.brapi.org/index.php/Search_Services\">Search Services</a></div> </div>  <div class=\"brapi-section\"> <h2 class=\"brapi-section-title\">BrAPI Core</h2> <div class=\"brapi-section-description\">The BrAPI Core module contains high level entities used for organization and management. This includes Programs, Trials, Studies, Locations, People, and Lists</div> <div class=\"version-number\">V2.1</div> <div class=\"link-btn\"><a href=\"https://github.com/plantbreeding/API/tree/brapi-V2.1/Specification/BrAPI-Core\">GitHub</a></div> <div class=\"link-btn\"><a href=\"https://app.swaggerhub.com/apis/PlantBreedingAPI/BrAPI-Core/2.1\">SwaggerHub</a></div> <div class=\"link-btn\"><a href=\"https://brapicore21.docs.apiary.io\">Apiary</a></div> <div class=\"stop-float\"></div> </div>  <div class=\"current-brapi-section brapi-section\"> <h2 class=\"brapi-section-title\">BrAPI Phenotyping</h2> <div class=\"brapi-section-description\">The BrAPI Phenotyping module contains entities related to phenotypic observations. This includes Observation Units, Observations, Observation Variables, Traits, Scales, Methods, and Images</div> <div class=\"version-number\">V2.1</div> <div class=\"link-btn\"><a href=\"https://github.com/plantbreeding/API/tree/brapi-V2.1/Specification/BrAPI-Phenotyping\">GitHub</a></div> <div class=\"link-btn\"><a href=\"https://app.swaggerhub.com/apis/PlantBreedingAPI/BrAPI-Phenotyping/2.1\">SwaggerHub</a></div> <div class=\"link-btn\"><a href=\"https://brapiphenotyping21.docs.apiary.io\">Apiary</a></div> <div class=\"stop-float\"></div> </div>  <div class=\"brapi-section\"> <h2 class=\"brapi-section-title\">BrAPI Genotyping</h2> <div class=\"brapi-section-description\">The BrAPI Genotyping module contains entities related to genotyping analysis. This includes Samples, Markers, Variant Sets, Variants, Call Sets, Calls, References, Reads, and Vendor Orders</div> <div class=\"version-number\">V2.1</div> <div class=\"link-btn\"><a href=\"https://github.com/plantbreeding/API/tree/brapi-V2.1/Specification/BrAPI-Genotyping\">GitHub</a></div> <div class=\"link-btn\"><a href=\"https://app.swaggerhub.com/apis/PlantBreedingAPI/BrAPI-Genotyping/2.1\">SwaggerHub</a></div> <div class=\"link-btn\"><a href=\"https://brapigenotyping21.docs.apiary.io\">Apiary</a></div> <div class=\"stop-float\"></div> </div>  <div class=\"brapi-section\"> <h2 class=\"brapi-section-title\">BrAPI Germplasm</h2> <div class=\"brapi-section-description\">The BrAPI Germplasm module contains entities related to germplasm management. This includes Germplasm, Germplasm Attributes, Seed Lots, Crosses, Pedigree, and Progeny</div> <div class=\"version-number\">V2.1</div> <div class=\"link-btn\"><a href=\"https://github.com/plantbreeding/API/tree/brapi-V2.1/Specification/BrAPI-Germplasm\">GitHub</a></div> <div class=\"link-btn\"><a href=\"https://app.swaggerhub.com/apis/PlantBreedingAPI/BrAPI-Germplasm/2.1\">SwaggerHub</a></div> <div class=\"link-btn\"><a href=\"https://brapigermplasm21.docs.apiary.io\">Apiary</a></div> <div class=\"stop-float\"></div> </div>  <style> .link-btn{ float: left;  margin: 2px 10px 0 0;  padding: 0 5px;  border-radius: 5px;  background-color: #ddd; } .stop-float{   clear: both; } .version-number{   float: left;    margin: 5px 10px 0 5px; } .brapi-section-title{   margin: 0 10px 0 0;   font-size: 20px; } .current-brapi-section{   font-weight: bolder;   border-radius: 5px;    background-color: #ddd; } .brapi-section{   padding: 5px 5px;  } .brapi-section-description{   margin: 5px 0 0 5px; } </style>
 *
 * OpenAPI spec version: 2.1
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package org.brapi.client.v21.modules.phenotype;

import com.google.gson.reflect.TypeToken;
import org.brapi.client.v21.*;
import org.brapi.client.v21.model.queryParams.phenotype.ImageQueryParams;
import org.brapi.model.v21.phenotype.*;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class ImagesApi {
    private ApiClient apiClient;

    public ImagesApi() {
        this(Configuration.getDefaultApiClient());
    }

    public ImagesApi(ApiClient apiClient) {
        this.apiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return apiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.apiClient = apiClient;
    }

    /**
     * Build call for deleteImagesPost
     *
     * @param body                    (optional)
     * @param authorization           HTTP HEADER - Token used for Authorization   &lt;strong&gt; Bearer {token_string} &lt;/strong&gt; (optional)
     * @param progressListener        Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call deleteImagesPostCall(ImageSearchRequest body, String authorization, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {

        // create path and map variables
        String localVarPath = "/delete/images";

        List<Pair> localVarQueryParams = new ArrayList<>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<>();

        Map<String, String> localVarHeaderParams = new HashMap<>();
        if (authorization != null)
            localVarHeaderParams.put("Authorization", apiClient.parameterToString(authorization));

        Map<String, Object> localVarFormParams = new HashMap<>();

        final String[] localVarAccepts = {
                "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
                "application/json"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if (progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(chain -> {
                com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                return originalResponse.newBuilder()
                        .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                        .build();
            });
        }

        String[] localVarAuthNames = new String[]{"AuthorizationToken"};
        return apiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, body, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    private com.squareup.okhttp.Call deleteImagesPostValidateBeforeCall(ImageSearchRequest body, String authorization, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {

        return deleteImagesPostCall(body, authorization, progressListener, progressRequestListener);


    }

    /**
     * Submit a delete request for &#x60;Images&#x60;
     * Submit a delete request for &#x60;Images&#x60;
     *
     * @param body          (optional)
     * @param authorization HTTP HEADER - Token used for Authorization   &lt;strong&gt; Bearer {token_string} &lt;/strong&gt; (optional)
     * @return ImageDeleteResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ImageDeleteResponse deleteImagesPost(ImageSearchRequest body, String authorization) throws ApiException {
        ApiResponse<ImageDeleteResponse> resp = deleteImagesPostWithHttpInfo(body, authorization);
        return resp.getData();
    }

    /**
     * Submit a delete request for &#x60;Images&#x60;
     * Submit a delete request for &#x60;Images&#x60;
     *
     * @param body          (optional)
     * @param authorization HTTP HEADER - Token used for Authorization   &lt;strong&gt; Bearer {token_string} &lt;/strong&gt; (optional)
     * @return ApiResponse&lt;ImageDeleteResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<ImageDeleteResponse> deleteImagesPostWithHttpInfo(ImageSearchRequest body, String authorization) throws ApiException {
        com.squareup.okhttp.Call call = deleteImagesPostValidateBeforeCall(body, authorization, null, null);
        Type localVarReturnType = new TypeToken<ImageDeleteResponse>() {
        }.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Submit a delete request for &#x60;Images&#x60; (asynchronously)
     * Submit a delete request for &#x60;Images&#x60;
     *
     * @param body          (optional)
     * @param authorization HTTP HEADER - Token used for Authorization   &lt;strong&gt; Bearer {token_string} &lt;/strong&gt; (optional)
     * @param callback      The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call deleteImagesPostAsync(ImageSearchRequest body, String authorization, final ApiCallback<ImageDeleteResponse> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = callback::onDownloadProgress;

            progressRequestListener = callback::onUploadProgress;
        }

        com.squareup.okhttp.Call call = deleteImagesPostValidateBeforeCall(body, authorization, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<ImageDeleteResponse>() {
        }.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }

    /**
     * Build call for imagesGet
     *
     * @param progressListener        Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call imagesGetCall(ImageQueryParams queryParams, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/images";

        List<Pair> localVarQueryParams = new ArrayList<>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<>();

        Map<String, String> localVarHeaderParams = new HashMap<>();

        queryParams.buildQueryParams(apiClient, localVarQueryParams, localVarHeaderParams);

        Map<String, Object> localVarFormParams = new HashMap<>();

        final String[] localVarAccepts = {
                "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {

        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if (progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(chain -> {
                com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                return originalResponse.newBuilder()
                        .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                        .build();
            });
        }

        String[] localVarAuthNames = new String[]{"AuthorizationToken"};
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    private com.squareup.okhttp.Call imagesGetValidateBeforeCall(ImageQueryParams queryParams, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {

        return imagesGetCall(queryParams, progressListener, progressRequestListener);


    }

    /**
     * Get the image metadata summaries
     * Get filtered set of image metadata  Implementation Notes  - &#x27;&#x27;imageURL&#x27;&#x27; should be a complete URL describing the location of the image. There is no BrAPI call for  retrieving the image content, so it could be on a different path, or a different host.  - &#x27;&#x27;descriptiveOntologyTerm&#x27;&#x27; can be thought of as Tags for the image. These could be simple descriptive  words, or ontology references, or full ontology URI&#x27;&#x27;s.
     *
     * @return ImageListResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ImageListResponse imagesGet(ImageQueryParams queryParams) throws ApiException {
        ApiResponse<ImageListResponse> resp = imagesGetWithHttpInfo(queryParams);
        return resp.getData();
    }

    /**
     * Get the image metadata summaries
     * Get filtered set of image metadata  Implementation Notes  - &#x27;&#x27;imageURL&#x27;&#x27; should be a complete URL describing the location of the image. There is no BrAPI call for  retrieving the image content, so it could be on a different path, or a different host.  - &#x27;&#x27;descriptiveOntologyTerm&#x27;&#x27; can be thought of as Tags for the image. These could be simple descriptive  words, or ontology references, or full ontology URI&#x27;&#x27;s.
     *
     * @return ApiResponse&lt;ImageListResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<ImageListResponse> imagesGetWithHttpInfo(ImageQueryParams queryParams) throws ApiException {
        com.squareup.okhttp.Call call = imagesGetValidateBeforeCall(queryParams, null, null);
        Type localVarReturnType = new TypeToken<ImageListResponse>() {
        }.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Get the image metadata summaries (asynchronously)
     * Get filtered set of image metadata  Implementation Notes  - &#x27;&#x27;imageURL&#x27;&#x27; should be a complete URL describing the location of the image. There is no BrAPI call for  retrieving the image content, so it could be on a different path, or a different host.  - &#x27;&#x27;descriptiveOntologyTerm&#x27;&#x27; can be thought of as Tags for the image. These could be simple descriptive  words, or ontology references, or full ontology URI&#x27;&#x27;s.
     *
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call imagesGetAsync(ImageQueryParams queryParams, final ApiCallback<ImageListResponse> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = callback::onDownloadProgress;

            progressRequestListener = callback::onUploadProgress;
        }

        com.squareup.okhttp.Call call = imagesGetValidateBeforeCall(queryParams, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<ImageListResponse>() {
        }.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }

    /**
     * Build call for imagesImageDbIdGet
     *
     * @param imageDbId               The unique identifier for a image (required)
     * @param authorization           HTTP HEADER - Token used for Authorization   &lt;strong&gt; Bearer {token_string} &lt;/strong&gt; (optional)
     * @param progressListener        Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call imagesImageDbIdGetCall(String imageDbId, String authorization, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/images/{imageDbId}"
                .replaceAll("\\{" + "imageDbId" + "}", apiClient.escapeString(imageDbId));

        List<Pair> localVarQueryParams = new ArrayList<>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<>();

        Map<String, String> localVarHeaderParams = new HashMap<>();
        if (authorization != null)
            localVarHeaderParams.put("Authorization", apiClient.parameterToString(authorization));

        Map<String, Object> localVarFormParams = new HashMap<>();

        final String[] localVarAccepts = {
                "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {

        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if (progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(chain -> {
                com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                return originalResponse.newBuilder()
                        .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                        .build();
            });
        }

        String[] localVarAuthNames = new String[]{"AuthorizationToken"};
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    private com.squareup.okhttp.Call imagesImageDbIdGetValidateBeforeCall(String imageDbId, String authorization, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        // verify the required parameter 'imageDbId' is set
        if (imageDbId == null) {
            throw new ApiException("Missing the required parameter 'imageDbId' when calling imagesImageDbIdGet(Async)");
        }

        return imagesImageDbIdGetCall(imageDbId, authorization, progressListener, progressRequestListener);


    }

    /**
     * Get the an image metadata summary
     * Get one image metadata object  Implementation Notes  - &#x27;&#x27;imageURL&#x27;&#x27; should be a complete URL describing the location of the image. There is no BrAPI call for  retrieving the image content, so it could be on a different path, or a different host.  - &#x27;&#x27;descriptiveOntologyTerm&#x27;&#x27; can be thought of as Tags for the image. These could be simple descriptive  words, or ontology references, or full ontology URI&#x27;&#x27;s.
     *
     * @param imageDbId     The unique identifier for a image (required)
     * @param authorization HTTP HEADER - Token used for Authorization   &lt;strong&gt; Bearer {token_string} &lt;/strong&gt; (optional)
     * @return ImageSingleResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ImageSingleResponse imagesImageDbIdGet(String imageDbId, String authorization) throws ApiException {
        ApiResponse<ImageSingleResponse> resp = imagesImageDbIdGetWithHttpInfo(imageDbId, authorization);
        return resp.getData();
    }

    /**
     * Get the an image metadata summary
     * Get one image metadata object  Implementation Notes  - &#x27;&#x27;imageURL&#x27;&#x27; should be a complete URL describing the location of the image. There is no BrAPI call for  retrieving the image content, so it could be on a different path, or a different host.  - &#x27;&#x27;descriptiveOntologyTerm&#x27;&#x27; can be thought of as Tags for the image. These could be simple descriptive  words, or ontology references, or full ontology URI&#x27;&#x27;s.
     *
     * @param imageDbId     The unique identifier for a image (required)
     * @param authorization HTTP HEADER - Token used for Authorization   &lt;strong&gt; Bearer {token_string} &lt;/strong&gt; (optional)
     * @return ApiResponse&lt;ImageSingleResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<ImageSingleResponse> imagesImageDbIdGetWithHttpInfo(String imageDbId, String authorization) throws ApiException {
        com.squareup.okhttp.Call call = imagesImageDbIdGetValidateBeforeCall(imageDbId, authorization, null, null);
        Type localVarReturnType = new TypeToken<ImageSingleResponse>() {
        }.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Get the an image metadata summary (asynchronously)
     * Get one image metadata object  Implementation Notes  - &#x27;&#x27;imageURL&#x27;&#x27; should be a complete URL describing the location of the image. There is no BrAPI call for  retrieving the image content, so it could be on a different path, or a different host.  - &#x27;&#x27;descriptiveOntologyTerm&#x27;&#x27; can be thought of as Tags for the image. These could be simple descriptive  words, or ontology references, or full ontology URI&#x27;&#x27;s.
     *
     * @param imageDbId     The unique identifier for a image (required)
     * @param authorization HTTP HEADER - Token used for Authorization   &lt;strong&gt; Bearer {token_string} &lt;/strong&gt; (optional)
     * @param callback      The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call imagesImageDbIdGetAsync(String imageDbId, String authorization, final ApiCallback<ImageSingleResponse> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = callback::onDownloadProgress;

            progressRequestListener = callback::onUploadProgress;
        }

        com.squareup.okhttp.Call call = imagesImageDbIdGetValidateBeforeCall(imageDbId, authorization, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<ImageSingleResponse>() {
        }.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }

    /**
     * Build call for imagesImageDbIdImagecontentPut
     *
     * @param imageDbId               The unique identifier for an image (required)
     * @param body                    (optional)
     * @param authorization           HTTP HEADER - Token used for Authorization   &lt;strong&gt; Bearer {token_string} &lt;/strong&gt; (optional)
     * @param progressListener        Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call imagesImageDbIdImagecontentPutCall(String imageDbId, Object body, String authorization, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {

        // create path and map variables
        String localVarPath = "/images/{imageDbId}/imagecontent"
                .replaceAll("\\{" + "imageDbId" + "}", apiClient.escapeString(imageDbId));

        List<Pair> localVarQueryParams = new ArrayList<>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<>();

        Map<String, String> localVarHeaderParams = new HashMap<>();
        if (authorization != null)
            localVarHeaderParams.put("Authorization", apiClient.parameterToString(authorization));

        Map<String, Object> localVarFormParams = new HashMap<>();

        final String[] localVarAccepts = {
                "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
                "image/_*"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if (progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(chain -> {
                com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                return originalResponse.newBuilder()
                        .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                        .build();
            });
        }

        String[] localVarAuthNames = new String[]{"AuthorizationToken"};
        return apiClient.buildCall(localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, body, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    private com.squareup.okhttp.Call imagesImageDbIdImagecontentPutValidateBeforeCall(String imageDbId, Object body, String authorization, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        // verify the required parameter 'imageDbId' is set
        if (imageDbId == null) {
            throw new ApiException("Missing the required parameter 'imageDbId' when calling imagesImageDbIdImagecontentPut(Async)");
        }

        return imagesImageDbIdImagecontentPutCall(imageDbId, body, authorization, progressListener, progressRequestListener);


    }

    /**
     * Attach an image binary file to an existing image metadata record
     * This endpoint is used to attach an image binary file to an existing image metadata record. All of the other Images endpoints  deal with the JSON for image metadata, but &#x27;PUT /images/{imageDbId}/imagecontent&#x27; allows you to send any binary file with a Content  Type (MIME) of image/_*. When the real image is uploaded, the server may choose to update some of the metadata to reflect the  reality of the image that was uploaded, and should respond with the updated JSON.  Implementation Notes  - This endpoint should be implemented with &#x27;POST /images&#x27; for full image upload capability  - This endpoint should be implemented with &#x27;PUT /images/{imageDbId}&#x27; for full image update capability  - A server may choose to modify the image metadata object based on the actually image which has been uploaded by this endpoint.   - Image data may be stored in a database or file system. Servers should generate and provide the \&quot;imageURL\&quot; for retrieving the    image binary file.   An example use case is available on the BrAPI Wiki -&gt; https://wiki.brapi.org/index.php/Image_Upload
     *
     * @param imageDbId     The unique identifier for an image (required)
     * @param body          (optional)
     * @param authorization HTTP HEADER - Token used for Authorization   &lt;strong&gt; Bearer {token_string} &lt;/strong&gt; (optional)
     * @return ImageSingleResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ImageSingleResponse imagesImageDbIdImagecontentPut(String imageDbId, Object body, String authorization) throws ApiException {
        ApiResponse<ImageSingleResponse> resp = imagesImageDbIdImagecontentPutWithHttpInfo(imageDbId, body, authorization);
        return resp.getData();
    }

    /**
     * Attach an image binary file to an existing image metadata record
     * This endpoint is used to attach an image binary file to an existing image metadata record. All of the other Images endpoints  deal with the JSON for image metadata, but &#x27;PUT /images/{imageDbId}/imagecontent&#x27; allows you to send any binary file with a Content  Type (MIME) of image/_*. When the real image is uploaded, the server may choose to update some of the metadata to reflect the  reality of the image that was uploaded, and should respond with the updated JSON.  Implementation Notes  - This endpoint should be implemented with &#x27;POST /images&#x27; for full image upload capability  - This endpoint should be implemented with &#x27;PUT /images/{imageDbId}&#x27; for full image update capability  - A server may choose to modify the image metadata object based on the actually image which has been uploaded by this endpoint.   - Image data may be stored in a database or file system. Servers should generate and provide the \&quot;imageURL\&quot; for retrieving the    image binary file.   An example use case is available on the BrAPI Wiki -&gt; https://wiki.brapi.org/index.php/Image_Upload
     *
     * @param imageDbId     The unique identifier for an image (required)
     * @param body          (optional)
     * @param authorization HTTP HEADER - Token used for Authorization   &lt;strong&gt; Bearer {token_string} &lt;/strong&gt; (optional)
     * @return ApiResponse&lt;ImageSingleResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<ImageSingleResponse> imagesImageDbIdImagecontentPutWithHttpInfo(String imageDbId, Object body, String authorization) throws ApiException {
        com.squareup.okhttp.Call call = imagesImageDbIdImagecontentPutValidateBeforeCall(imageDbId, body, authorization, null, null);
        Type localVarReturnType = new TypeToken<ImageSingleResponse>() {
        }.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Attach an image binary file to an existing image metadata record (asynchronously)
     * This endpoint is used to attach an image binary file to an existing image metadata record. All of the other Images endpoints  deal with the JSON for image metadata, but &#x27;PUT /images/{imageDbId}/imagecontent&#x27; allows you to send any binary file with a Content  Type (MIME) of image/_*. When the real image is uploaded, the server may choose to update some of the metadata to reflect the  reality of the image that was uploaded, and should respond with the updated JSON.  Implementation Notes  - This endpoint should be implemented with &#x27;POST /images&#x27; for full image upload capability  - This endpoint should be implemented with &#x27;PUT /images/{imageDbId}&#x27; for full image update capability  - A server may choose to modify the image metadata object based on the actually image which has been uploaded by this endpoint.   - Image data may be stored in a database or file system. Servers should generate and provide the \&quot;imageURL\&quot; for retrieving the    image binary file.   An example use case is available on the BrAPI Wiki -&gt; https://wiki.brapi.org/index.php/Image_Upload
     *
     * @param imageDbId     The unique identifier for an image (required)
     * @param body          (optional)
     * @param authorization HTTP HEADER - Token used for Authorization   &lt;strong&gt; Bearer {token_string} &lt;/strong&gt; (optional)
     * @param callback      The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call imagesImageDbIdImagecontentPutAsync(String imageDbId, Object body, String authorization, final ApiCallback<ImageSingleResponse> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = callback::onDownloadProgress;

            progressRequestListener = callback::onUploadProgress;
        }

        com.squareup.okhttp.Call call = imagesImageDbIdImagecontentPutValidateBeforeCall(imageDbId, body, authorization, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<ImageSingleResponse>() {
        }.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }

    /**
     * Build call for imagesImageDbIdPut
     *
     * @param imageDbId               The unique identifier for a image (required)
     * @param body                    (optional)
     * @param authorization           HTTP HEADER - Token used for Authorization   &lt;strong&gt; Bearer {token_string} &lt;/strong&gt; (optional)
     * @param progressListener        Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call imagesImageDbIdPutCall(String imageDbId, ImageNewRequest body, String authorization, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {

        // create path and map variables
        String localVarPath = "/images/{imageDbId}"
                .replaceAll("\\{" + "imageDbId" + "}", apiClient.escapeString(imageDbId));

        List<Pair> localVarQueryParams = new ArrayList<>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<>();

        Map<String, String> localVarHeaderParams = new HashMap<>();
        if (authorization != null)
            localVarHeaderParams.put("Authorization", apiClient.parameterToString(authorization));

        Map<String, Object> localVarFormParams = new HashMap<>();

        final String[] localVarAccepts = {
                "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
                "application/json"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if (progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(chain -> {
                com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                return originalResponse.newBuilder()
                        .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                        .build();
            });
        }

        String[] localVarAuthNames = new String[]{"AuthorizationToken"};
        return apiClient.buildCall(localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, body, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    private com.squareup.okhttp.Call imagesImageDbIdPutValidateBeforeCall(String imageDbId, ImageNewRequest body, String authorization, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        // verify the required parameter 'imageDbId' is set
        if (imageDbId == null) {
            throw new ApiException("Missing the required parameter 'imageDbId' when calling imagesImageDbIdPut(Async)");
        }

        return imagesImageDbIdPutCall(imageDbId, body, authorization, progressListener, progressRequestListener);


    }

    /**
     * Update an existing image metadata record
     * Update an existing image metadata record  Implementation Notes  - This endpoint should be implemented with &#x27;PUT /images/{imageDbId}/imagecontent&#x27; for full image update capability  - A server may choose to modify the image metadata object based on the actually image which has been uploaded.   - Image data may be stored in a database or file system. Servers should generate and provide the \&quot;imageURL\&quot; as an  absolute path for retrieving the image, wherever it happens to live.   - &#x27;descriptiveOntologyTerm&#x27; can be thought of as Tags for the image. These could be simple descriptive words, or  ontology references, or full ontology URI&#x27;s.   - The &#x27;/images&#x27; calls support a GeoJSON object structure for describing their location. The BrAPI spec for GeoJSON  only supports two of the possible geometries; Points and Polygons.   - With most images, the Point geometry should be used, and it should indicate the longitude and latitude of the camera.   - For top down images (ie from drones, cranes, etc), the Point geometry may be used to indicate the longitude and  latitude of the centroid of the image content, and the Polygon geometry may be used to indicate the border of the  image content.  An example use case is available on the BrAPI Wiki -&gt; https://wiki.brapi.org/index.php/Image_Upload
     *
     * @param imageDbId     The unique identifier for a image (required)
     * @param body          (optional)
     * @param authorization HTTP HEADER - Token used for Authorization   &lt;strong&gt; Bearer {token_string} &lt;/strong&gt; (optional)
     * @return ImageSingleResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ImageSingleResponse imagesImageDbIdPut(String imageDbId, ImageNewRequest body, String authorization) throws ApiException {
        ApiResponse<ImageSingleResponse> resp = imagesImageDbIdPutWithHttpInfo(imageDbId, body, authorization);
        return resp.getData();
    }

    /**
     * Update an existing image metadata record
     * Update an existing image metadata record  Implementation Notes  - This endpoint should be implemented with &#x27;PUT /images/{imageDbId}/imagecontent&#x27; for full image update capability  - A server may choose to modify the image metadata object based on the actually image which has been uploaded.   - Image data may be stored in a database or file system. Servers should generate and provide the \&quot;imageURL\&quot; as an  absolute path for retrieving the image, wherever it happens to live.   - &#x27;descriptiveOntologyTerm&#x27; can be thought of as Tags for the image. These could be simple descriptive words, or  ontology references, or full ontology URI&#x27;s.   - The &#x27;/images&#x27; calls support a GeoJSON object structure for describing their location. The BrAPI spec for GeoJSON  only supports two of the possible geometries; Points and Polygons.   - With most images, the Point geometry should be used, and it should indicate the longitude and latitude of the camera.   - For top down images (ie from drones, cranes, etc), the Point geometry may be used to indicate the longitude and  latitude of the centroid of the image content, and the Polygon geometry may be used to indicate the border of the  image content.  An example use case is available on the BrAPI Wiki -&gt; https://wiki.brapi.org/index.php/Image_Upload
     *
     * @param imageDbId     The unique identifier for a image (required)
     * @param body          (optional)
     * @param authorization HTTP HEADER - Token used for Authorization   &lt;strong&gt; Bearer {token_string} &lt;/strong&gt; (optional)
     * @return ApiResponse&lt;ImageSingleResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<ImageSingleResponse> imagesImageDbIdPutWithHttpInfo(String imageDbId, ImageNewRequest body, String authorization) throws ApiException {
        com.squareup.okhttp.Call call = imagesImageDbIdPutValidateBeforeCall(imageDbId, body, authorization, null, null);
        Type localVarReturnType = new TypeToken<ImageSingleResponse>() {
        }.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Update an existing image metadata record (asynchronously)
     * Update an existing image metadata record  Implementation Notes  - This endpoint should be implemented with &#x27;PUT /images/{imageDbId}/imagecontent&#x27; for full image update capability  - A server may choose to modify the image metadata object based on the actually image which has been uploaded.   - Image data may be stored in a database or file system. Servers should generate and provide the \&quot;imageURL\&quot; as an  absolute path for retrieving the image, wherever it happens to live.   - &#x27;descriptiveOntologyTerm&#x27; can be thought of as Tags for the image. These could be simple descriptive words, or  ontology references, or full ontology URI&#x27;s.   - The &#x27;/images&#x27; calls support a GeoJSON object structure for describing their location. The BrAPI spec for GeoJSON  only supports two of the possible geometries; Points and Polygons.   - With most images, the Point geometry should be used, and it should indicate the longitude and latitude of the camera.   - For top down images (ie from drones, cranes, etc), the Point geometry may be used to indicate the longitude and  latitude of the centroid of the image content, and the Polygon geometry may be used to indicate the border of the  image content.  An example use case is available on the BrAPI Wiki -&gt; https://wiki.brapi.org/index.php/Image_Upload
     *
     * @param imageDbId     The unique identifier for a image (required)
     * @param body          (optional)
     * @param authorization HTTP HEADER - Token used for Authorization   &lt;strong&gt; Bearer {token_string} &lt;/strong&gt; (optional)
     * @param callback      The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call imagesImageDbIdPutAsync(String imageDbId, ImageNewRequest body, String authorization, final ApiCallback<ImageSingleResponse> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = callback::onDownloadProgress;

            progressRequestListener = callback::onUploadProgress;
        }

        com.squareup.okhttp.Call call = imagesImageDbIdPutValidateBeforeCall(imageDbId, body, authorization, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<ImageSingleResponse>() {
        }.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }

    /**
     * Build call for imagesPost
     *
     * @param body                    (optional)
     * @param authorization           HTTP HEADER - Token used for Authorization   &lt;strong&gt; Bearer {token_string} &lt;/strong&gt; (optional)
     * @param progressListener        Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call imagesPostCall(List<ImageNewRequest> body, String authorization, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {

        // create path and map variables
        String localVarPath = "/images";

        List<Pair> localVarQueryParams = new ArrayList<>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<>();

        Map<String, String> localVarHeaderParams = new HashMap<>();
        if (authorization != null)
            localVarHeaderParams.put("Authorization", apiClient.parameterToString(authorization));

        Map<String, Object> localVarFormParams = new HashMap<>();

        final String[] localVarAccepts = {
                "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
                "application/json"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if (progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(chain -> {
                com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                return originalResponse.newBuilder()
                        .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                        .build();
            });
        }

        String[] localVarAuthNames = new String[]{"AuthorizationToken"};
        return apiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, body, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    private com.squareup.okhttp.Call imagesPostValidateBeforeCall(List<ImageNewRequest> body, String authorization, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {

        return imagesPostCall(body, authorization, progressListener, progressRequestListener);


    }

    /**
     * Create new image metadata records
     * Create new image metadata records  Implementation Notes  - This endpoint should be implemented with &#x27;PUT /images/{imageDbId}/imagecontent&#x27; for full image upload capability  - &#x27;&#x27;imageURL&#x27;&#x27; should be a complete URL describing the location of the image. There is no BrAPI call for retrieving  the image content, so it could be on a different path, or a different host.  - &#x27;&#x27;descriptiveOntologyTerm&#x27;&#x27; can be thought of as Tags for the image. These could be simple descriptive words, or  ontology references, or full ontology URI&#x27;s.  - The &#x27;/images&#x27; calls support a GeoJSON object structure for describing their location. The BrAPI spec for GeoJSON  only supports two of the possible geometries; Points and Polygons.  - With most images, the Point geometry should be used, and it should indicate the longitude and latitude of the camera.  - For top down images (ie from drones, cranes, etc), the Point geometry may be used to indicate the longitude and  latitude of the centroid of the image content, and the Polygon geometry may be used to indicate the border of the  image content.  An example use case is available on the BrAPI Wiki -&gt; https://wiki.brapi.org/index.php/Image_Upload
     *
     * @param body          (optional)
     * @param authorization HTTP HEADER - Token used for Authorization   &lt;strong&gt; Bearer {token_string} &lt;/strong&gt; (optional)
     * @return ImageListResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ImageListResponse imagesPost(List<ImageNewRequest> body, String authorization) throws ApiException {
        ApiResponse<ImageListResponse> resp = imagesPostWithHttpInfo(body, authorization);
        return resp.getData();
    }

    /**
     * Create new image metadata records
     * Create new image metadata records  Implementation Notes  - This endpoint should be implemented with &#x27;PUT /images/{imageDbId}/imagecontent&#x27; for full image upload capability  - &#x27;&#x27;imageURL&#x27;&#x27; should be a complete URL describing the location of the image. There is no BrAPI call for retrieving  the image content, so it could be on a different path, or a different host.  - &#x27;&#x27;descriptiveOntologyTerm&#x27;&#x27; can be thought of as Tags for the image. These could be simple descriptive words, or  ontology references, or full ontology URI&#x27;s.  - The &#x27;/images&#x27; calls support a GeoJSON object structure for describing their location. The BrAPI spec for GeoJSON  only supports two of the possible geometries; Points and Polygons.  - With most images, the Point geometry should be used, and it should indicate the longitude and latitude of the camera.  - For top down images (ie from drones, cranes, etc), the Point geometry may be used to indicate the longitude and  latitude of the centroid of the image content, and the Polygon geometry may be used to indicate the border of the  image content.  An example use case is available on the BrAPI Wiki -&gt; https://wiki.brapi.org/index.php/Image_Upload
     *
     * @param body          (optional)
     * @param authorization HTTP HEADER - Token used for Authorization   &lt;strong&gt; Bearer {token_string} &lt;/strong&gt; (optional)
     * @return ApiResponse&lt;ImageListResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<ImageListResponse> imagesPostWithHttpInfo(List<ImageNewRequest> body, String authorization) throws ApiException {
        com.squareup.okhttp.Call call = imagesPostValidateBeforeCall(body, authorization, null, null);
        Type localVarReturnType = new TypeToken<ImageListResponse>() {
        }.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Create new image metadata records (asynchronously)
     * Create new image metadata records  Implementation Notes  - This endpoint should be implemented with &#x27;PUT /images/{imageDbId}/imagecontent&#x27; for full image upload capability  - &#x27;&#x27;imageURL&#x27;&#x27; should be a complete URL describing the location of the image. There is no BrAPI call for retrieving  the image content, so it could be on a different path, or a different host.  - &#x27;&#x27;descriptiveOntologyTerm&#x27;&#x27; can be thought of as Tags for the image. These could be simple descriptive words, or  ontology references, or full ontology URI&#x27;s.  - The &#x27;/images&#x27; calls support a GeoJSON object structure for describing their location. The BrAPI spec for GeoJSON  only supports two of the possible geometries; Points and Polygons.  - With most images, the Point geometry should be used, and it should indicate the longitude and latitude of the camera.  - For top down images (ie from drones, cranes, etc), the Point geometry may be used to indicate the longitude and  latitude of the centroid of the image content, and the Polygon geometry may be used to indicate the border of the  image content.  An example use case is available on the BrAPI Wiki -&gt; https://wiki.brapi.org/index.php/Image_Upload
     *
     * @param body          (optional)
     * @param authorization HTTP HEADER - Token used for Authorization   &lt;strong&gt; Bearer {token_string} &lt;/strong&gt; (optional)
     * @param callback      The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call imagesPostAsync(List<ImageNewRequest> body, String authorization, final ApiCallback<ImageListResponse> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = callback::onDownloadProgress;

            progressRequestListener = callback::onUploadProgress;
        }

        com.squareup.okhttp.Call call = imagesPostValidateBeforeCall(body, authorization, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<ImageListResponse>() {
        }.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }

    /**
     * Build call for searchImagesPost
     *
     * @param body                    (optional)
     * @param authorization           HTTP HEADER - Token used for Authorization   &lt;strong&gt; Bearer {token_string} &lt;/strong&gt; (optional)
     * @param progressListener        Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call searchImagesPostCall(SearchImagesBody body, String authorization, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {

        // create path and map variables
        String localVarPath = "/search/images";

        List<Pair> localVarQueryParams = new ArrayList<>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<>();

        Map<String, String> localVarHeaderParams = new HashMap<>();
        if (authorization != null)
            localVarHeaderParams.put("Authorization", apiClient.parameterToString(authorization));

        Map<String, Object> localVarFormParams = new HashMap<>();

        final String[] localVarAccepts = {
                "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
                "application/json"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if (progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(chain -> {
                com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                return originalResponse.newBuilder()
                        .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                        .build();
            });
        }

        String[] localVarAuthNames = new String[]{"AuthorizationToken"};
        return apiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, body, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    private com.squareup.okhttp.Call searchImagesPostValidateBeforeCall(SearchImagesBody body, String authorization, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {

        return searchImagesPostCall(body, authorization, progressListener, progressRequestListener);


    }

    /**
     * Submit a search request for &#x60;XXEntitiesXX&#x60;
     * Submit a search request for &#x60;XXEntitiesXX&#x60;&lt;br/&gt; Search requests allow a client to send a complex query for data. However, the server may not respond with the search results immediately.  If a server needs more time to process the request, it might respond with a &#x60;searchResultsDbId&#x60;.  Use the corresponding &#x60;GET /search/XXEntitiesXX/{searchResultsDbId}&#x60; to retrieve the results of the search. &lt;br/&gt;  Review the &lt;a target&#x3D;\&quot;_blank\&quot; href&#x3D;\&quot;https://wiki.brapi.org/index.php/Search_Services#POST_Search_Entity\&quot;&gt;Search Services documentation&lt;/a&gt; for additional implementation details. &lt;br/&gt; &lt;br/&gt; Image Implementation Notes&lt;br/&gt; - &#x60;imageURL&#x60; should be a complete URL describing the location of the image. There is no BrAPI call for retrieving the image content, so it could be on a different path, or a different host.&lt;br/&gt; - &#x60;descriptiveOntologyTerm&#x60; can be thought of as Tags for the image. These could be simple descriptive words, or ontology references, or full ontology URI&#x27;s.&lt;br/&gt;
     *
     * @param body          (optional)
     * @param authorization HTTP HEADER - Token used for Authorization   &lt;strong&gt; Bearer {token_string} &lt;/strong&gt; (optional)
     * @return ImageListResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ImageListResponse searchImagesPost(SearchImagesBody body, String authorization) throws ApiException {
        ApiResponse<ImageListResponse> resp = searchImagesPostWithHttpInfo(body, authorization);
        return resp.getData();
    }

    /**
     * Submit a search request for &#x60;XXEntitiesXX&#x60;
     * Submit a search request for &#x60;XXEntitiesXX&#x60;&lt;br/&gt; Search requests allow a client to send a complex query for data. However, the server may not respond with the search results immediately.  If a server needs more time to process the request, it might respond with a &#x60;searchResultsDbId&#x60;.  Use the corresponding &#x60;GET /search/XXEntitiesXX/{searchResultsDbId}&#x60; to retrieve the results of the search. &lt;br/&gt;  Review the &lt;a target&#x3D;\&quot;_blank\&quot; href&#x3D;\&quot;https://wiki.brapi.org/index.php/Search_Services#POST_Search_Entity\&quot;&gt;Search Services documentation&lt;/a&gt; for additional implementation details. &lt;br/&gt; &lt;br/&gt; Image Implementation Notes&lt;br/&gt; - &#x60;imageURL&#x60; should be a complete URL describing the location of the image. There is no BrAPI call for retrieving the image content, so it could be on a different path, or a different host.&lt;br/&gt; - &#x60;descriptiveOntologyTerm&#x60; can be thought of as Tags for the image. These could be simple descriptive words, or ontology references, or full ontology URI&#x27;s.&lt;br/&gt;
     *
     * @param body          (optional)
     * @param authorization HTTP HEADER - Token used for Authorization   &lt;strong&gt; Bearer {token_string} &lt;/strong&gt; (optional)
     * @return ApiResponse&lt;ImageListResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<ImageListResponse> searchImagesPostWithHttpInfo(SearchImagesBody body, String authorization) throws ApiException {
        com.squareup.okhttp.Call call = searchImagesPostValidateBeforeCall(body, authorization, null, null);
        Type localVarReturnType = new TypeToken<ImageListResponse>() {
        }.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Submit a search request for &#x60;XXEntitiesXX&#x60; (asynchronously)
     * Submit a search request for &#x60;XXEntitiesXX&#x60;&lt;br/&gt; Search requests allow a client to send a complex query for data. However, the server may not respond with the search results immediately.  If a server needs more time to process the request, it might respond with a &#x60;searchResultsDbId&#x60;.  Use the corresponding &#x60;GET /search/XXEntitiesXX/{searchResultsDbId}&#x60; to retrieve the results of the search. &lt;br/&gt;  Review the &lt;a target&#x3D;\&quot;_blank\&quot; href&#x3D;\&quot;https://wiki.brapi.org/index.php/Search_Services#POST_Search_Entity\&quot;&gt;Search Services documentation&lt;/a&gt; for additional implementation details. &lt;br/&gt; &lt;br/&gt; Image Implementation Notes&lt;br/&gt; - &#x60;imageURL&#x60; should be a complete URL describing the location of the image. There is no BrAPI call for retrieving the image content, so it could be on a different path, or a different host.&lt;br/&gt; - &#x60;descriptiveOntologyTerm&#x60; can be thought of as Tags for the image. These could be simple descriptive words, or ontology references, or full ontology URI&#x27;s.&lt;br/&gt;
     *
     * @param body          (optional)
     * @param authorization HTTP HEADER - Token used for Authorization   &lt;strong&gt; Bearer {token_string} &lt;/strong&gt; (optional)
     * @param callback      The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call searchImagesPostAsync(SearchImagesBody body, String authorization, final ApiCallback<ImageListResponse> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = callback::onDownloadProgress;

            progressRequestListener = callback::onUploadProgress;
        }

        com.squareup.okhttp.Call call = searchImagesPostValidateBeforeCall(body, authorization, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<ImageListResponse>() {
        }.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }

    /**
     * Build call for searchImagesSearchResultsDbIdGet
     *
     * @param searchResultsDbId       Unique identifier which references the search results (required)
     * @param page                    Used to request a specific page of data to be returned.  The page indexing starts at 0 (the first page is &#x27;page&#x27;&#x3D; 0). Default is &#x60;0&#x60;. (optional)
     * @param pageSize                The size of the pages to be returned. Default is &#x60;1000&#x60;. (optional)
     * @param authorization           HTTP HEADER - Token used for Authorization   &lt;strong&gt; Bearer {token_string} &lt;/strong&gt; (optional)
     * @param progressListener        Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call searchImagesSearchResultsDbIdGetCall(String searchResultsDbId, Integer page, Integer pageSize, String authorization, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/search/images/{searchResultsDbId}"
                .replaceAll("\\{" + "searchResultsDbId" + "}", apiClient.escapeString(searchResultsDbId));

        List<Pair> localVarQueryParams = new ArrayList<>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<>();
        if (page != null)
            localVarQueryParams.addAll(apiClient.parameterToPair("page", page));
        if (pageSize != null)
            localVarQueryParams.addAll(apiClient.parameterToPair("pageSize", pageSize));

        Map<String, String> localVarHeaderParams = new HashMap<>();
        if (authorization != null)
            localVarHeaderParams.put("Authorization", apiClient.parameterToString(authorization));

        Map<String, Object> localVarFormParams = new HashMap<>();

        final String[] localVarAccepts = {
                "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {

        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if (progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(chain -> {
                com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                return originalResponse.newBuilder()
                        .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                        .build();
            });
        }

        String[] localVarAuthNames = new String[]{"AuthorizationToken"};
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    private com.squareup.okhttp.Call searchImagesSearchResultsDbIdGetValidateBeforeCall(String searchResultsDbId, Integer page, Integer pageSize, String authorization, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        // verify the required parameter 'searchResultsDbId' is set
        if (searchResultsDbId == null) {
            throw new ApiException("Missing the required parameter 'searchResultsDbId' when calling searchImagesSearchResultsDbIdGet(Async)");
        }

        return searchImagesSearchResultsDbIdGetCall(searchResultsDbId, page, pageSize, authorization, progressListener, progressRequestListener);


    }

    /**
     * Get the results of a &#x60;Images&#x60; search request
     * Get the results of a &#x60;Images&#x60; search request &lt;br/&gt; Clients should submit a search request using the corresponding &#x60;POST /search/images&#x60; endpoint. Search requests allow a client to send a complex query for data. However, the server may not respond with the search results immediately.  If a server needs more time to process the request, it might respond with a &#x60;searchResultsDbId&#x60;.  Use this endpoint to retrieve the results of the search. &lt;br/&gt;  Review the &lt;a target&#x3D;\&quot;_blank\&quot; href&#x3D;\&quot;https://wiki.brapi.org/index.php/Search_Services#POST_Search_Entity\&quot;&gt;Search Services documentation&lt;/a&gt; for additional implementation details. &lt;br/&gt; &lt;br/&gt; Image Implementation Notes&lt;br/&gt; - &#x60;imageURL&#x60; should be a complete URL describing the location of the image. There is no BrAPI call for retrieving the image content, so it could be on a different path, or a different host.&lt;br/&gt; - &#x60;descriptiveOntologyTerm&#x60; can be thought of as Tags for the image. These could be simple descriptive words, or ontology references, or full ontology URI&#x27;s.&lt;br/&gt;
     *
     * @param searchResultsDbId Unique identifier which references the search results (required)
     * @param page              Used to request a specific page of data to be returned.  The page indexing starts at 0 (the first page is &#x27;page&#x27;&#x3D; 0). Default is &#x60;0&#x60;. (optional)
     * @param pageSize          The size of the pages to be returned. Default is &#x60;1000&#x60;. (optional)
     * @param authorization     HTTP HEADER - Token used for Authorization   &lt;strong&gt; Bearer {token_string} &lt;/strong&gt; (optional)
     * @return ImageListResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ImageListResponse searchImagesSearchResultsDbIdGet(String searchResultsDbId, Integer page, Integer pageSize, String authorization) throws ApiException {
        ApiResponse<ImageListResponse> resp = searchImagesSearchResultsDbIdGetWithHttpInfo(searchResultsDbId, page, pageSize, authorization);
        return resp.getData();
    }

    /**
     * Get the results of a &#x60;Images&#x60; search request
     * Get the results of a &#x60;Images&#x60; search request &lt;br/&gt; Clients should submit a search request using the corresponding &#x60;POST /search/images&#x60; endpoint. Search requests allow a client to send a complex query for data. However, the server may not respond with the search results immediately.  If a server needs more time to process the request, it might respond with a &#x60;searchResultsDbId&#x60;.  Use this endpoint to retrieve the results of the search. &lt;br/&gt;  Review the &lt;a target&#x3D;\&quot;_blank\&quot; href&#x3D;\&quot;https://wiki.brapi.org/index.php/Search_Services#POST_Search_Entity\&quot;&gt;Search Services documentation&lt;/a&gt; for additional implementation details. &lt;br/&gt; &lt;br/&gt; Image Implementation Notes&lt;br/&gt; - &#x60;imageURL&#x60; should be a complete URL describing the location of the image. There is no BrAPI call for retrieving the image content, so it could be on a different path, or a different host.&lt;br/&gt; - &#x60;descriptiveOntologyTerm&#x60; can be thought of as Tags for the image. These could be simple descriptive words, or ontology references, or full ontology URI&#x27;s.&lt;br/&gt;
     *
     * @param searchResultsDbId Unique identifier which references the search results (required)
     * @param page              Used to request a specific page of data to be returned.  The page indexing starts at 0 (the first page is &#x27;page&#x27;&#x3D; 0). Default is &#x60;0&#x60;. (optional)
     * @param pageSize          The size of the pages to be returned. Default is &#x60;1000&#x60;. (optional)
     * @param authorization     HTTP HEADER - Token used for Authorization   &lt;strong&gt; Bearer {token_string} &lt;/strong&gt; (optional)
     * @return ApiResponse&lt;ImageListResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<ImageListResponse> searchImagesSearchResultsDbIdGetWithHttpInfo(String searchResultsDbId, Integer page, Integer pageSize, String authorization) throws ApiException {
        com.squareup.okhttp.Call call = searchImagesSearchResultsDbIdGetValidateBeforeCall(searchResultsDbId, page, pageSize, authorization, null, null);
        Type localVarReturnType = new TypeToken<ImageListResponse>() {
        }.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Get the results of a &#x60;Images&#x60; search request (asynchronously)
     * Get the results of a &#x60;Images&#x60; search request &lt;br/&gt; Clients should submit a search request using the corresponding &#x60;POST /search/images&#x60; endpoint. Search requests allow a client to send a complex query for data. However, the server may not respond with the search results immediately.  If a server needs more time to process the request, it might respond with a &#x60;searchResultsDbId&#x60;.  Use this endpoint to retrieve the results of the search. &lt;br/&gt;  Review the &lt;a target&#x3D;\&quot;_blank\&quot; href&#x3D;\&quot;https://wiki.brapi.org/index.php/Search_Services#POST_Search_Entity\&quot;&gt;Search Services documentation&lt;/a&gt; for additional implementation details. &lt;br/&gt; &lt;br/&gt; Image Implementation Notes&lt;br/&gt; - &#x60;imageURL&#x60; should be a complete URL describing the location of the image. There is no BrAPI call for retrieving the image content, so it could be on a different path, or a different host.&lt;br/&gt; - &#x60;descriptiveOntologyTerm&#x60; can be thought of as Tags for the image. These could be simple descriptive words, or ontology references, or full ontology URI&#x27;s.&lt;br/&gt;
     *
     * @param searchResultsDbId Unique identifier which references the search results (required)
     * @param page              Used to request a specific page of data to be returned.  The page indexing starts at 0 (the first page is &#x27;page&#x27;&#x3D; 0). Default is &#x60;0&#x60;. (optional)
     * @param pageSize          The size of the pages to be returned. Default is &#x60;1000&#x60;. (optional)
     * @param authorization     HTTP HEADER - Token used for Authorization   &lt;strong&gt; Bearer {token_string} &lt;/strong&gt; (optional)
     * @param callback          The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call searchImagesSearchResultsDbIdGetAsync(String searchResultsDbId, Integer page, Integer pageSize, String authorization, final ApiCallback<ImageListResponse> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = callback::onDownloadProgress;

            progressRequestListener = callback::onUploadProgress;
        }

        com.squareup.okhttp.Call call = searchImagesSearchResultsDbIdGetValidateBeforeCall(searchResultsDbId, page, pageSize, authorization, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<ImageListResponse>() {
        }.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
}
