/*
 * BrAPI-Phenotyping
 * The Breeding API (BrAPI) is a Standardized REST ful Web Service API Specification for communicating Plant Breeding Data. BrAPI allows for easy data sharing between databases and tools involved in plant breeding. <div class=\"brapi-section\"> <h2 class=\"brapi-section-title\">General Reference Documentation</h2> <div class=\"gen-info-link\"><a href=\"https://github.com/plantbreeding/API/blob/master/Specification/GeneralInfo/URL_Structure.md\">URL Structure</a></div> <div class=\"gen-info-link\"><a href=\"https://github.com/plantbreeding/API/blob/master/Specification/GeneralInfo/Response_Structure.md\">Response Structure</a></div> <div class=\"gen-info-link\"><a href=\"https://github.com/plantbreeding/API/blob/master/Specification/GeneralInfo/Date_Time_Encoding.md\">Date/Time Encoding</a></div> <div class=\"gen-info-link\"><a href=\"https://github.com/plantbreeding/API/blob/master/Specification/GeneralInfo/Location_Encoding.md\">Location Encoding</a></div> <div class=\"gen-info-link\"><a href=\"https://github.com/plantbreeding/API/blob/master/Specification/GeneralInfo/Error_Handling.md\">Error Handling</a></div> <div class=\"gen-info-link\"><a href=\"https://github.com/plantbreeding/API/blob/master/Specification/GeneralInfo/Search_Services.md\">Search Services</a></div> </div>  <div class=\"brapi-section\"> <h2 class=\"brapi-section-title\">BrAPI Core</h2> <div class=\"brapi-section-description\">The BrAPI Core module contains high level entities used for organization and management. This includes Programs, Trials, Studies, Locations, People, and Lists</div> <div class=\"version-number\">V2.0</div> <div class=\"link-btn\"><a href=\"https://github.com/plantbreeding/API/tree/master/Specification/BrAPI-Core\">GitHub</a></div> <div class=\"link-btn\"><a href=\"https://app.swaggerhub.com/apis/PlantBreedingAPI/BrAPI-Core\">SwaggerHub</a></div> <div class=\"link-btn\"><a href=\"https://brapicore.docs.apiary.io\">Apiary</a></div> <div class=\"stop-float\"></div> </div>  <div class=\"current-brapi-section brapi-section\"> <h2 class=\"brapi-section-title\">BrAPI Phenotyping</h2> <div class=\"brapi-section-description\">The BrAPI Phenotyping module contains entities related to phenotypic observations. This includes Observation Units, Observations, Observation Variables, Traits, Scales, Methods, and Images</div> <div class=\"version-number\">V2.0</div> <div class=\"link-btn\"><a href=\"https://github.com/plantbreeding/API/tree/master/Specification/BrAPI-Phenotyping\">GitHub</a></div> <div class=\"link-btn\"><a href=\"https://app.swaggerhub.com/apis/PlantBreedingAPI/BrAPI-Phenotyping\">SwaggerHub</a></div> <div class=\"link-btn\"><a href=\"https://brapiphenotyping.docs.apiary.io\">Apiary</a></div> <div class=\"stop-float\"></div> </div>  <div class=\"brapi-section\"> <h2 class=\"brapi-section-title\">BrAPI Genotyping</h2> <div class=\"brapi-section-description\">The BrAPI Genotyping module contains entities related to genotyping analysis. This includes Samples, Markers, Variant Sets, Variants, Call Sets, Calls, References, Reads, and Vendor Orders</div> <div class=\"version-number\">V2.0</div> <div class=\"link-btn\"><a href=\"https://github.com/plantbreeding/API/tree/master/Specification/BrAPI-Genotyping\">GitHub</a></div> <div class=\"link-btn\"><a href=\"https://app.swaggerhub.com/apis/PlantBreedingAPI/BrAPI-Genotyping\">SwaggerHub</a></div> <div class=\"link-btn\"><a href=\"https://brapigenotyping.docs.apiary.io\">Apiary</a></div> <div class=\"stop-float\"></div> </div>  <div class=\"brapi-section\"> <h2 class=\"brapi-section-title\">BrAPI Germplasm</h2> <div class=\"brapi-section-description\">The BrAPI Germplasm module contains entities related to germplasm management. This includes Germplasm, Germplasm Attributes, Seed Lots, Crosses, Pedigree, and Progeny</div> <div class=\"version-number\">V2.0</div> <div class=\"link-btn\"><a href=\"https://github.com/plantbreeding/API/tree/master/Specification/BrAPI-Germplasm\">GitHub</a></div> <div class=\"link-btn\"><a href=\"https://app.swaggerhub.com/apis/PlantBreedingAPI/BrAPI-Germplasm\">SwaggerHub</a></div> <div class=\"link-btn\"><a href=\"https://brapigermplasm.docs.apiary.io\">Apiary</a></div> <div class=\"stop-float\"></div> </div>  <style> .link-btn{ float: left;  margin: 2px 10px 0 0;  padding: 0 5px;  border-radius: 5px;  background-color: #ddd; } .stop-float{   clear: both; } .version-number{   float: left;    margin: 5px 10px 0 5px; } .brapi-section-title{   margin: 0 10px 0 0;   font-size: 20px; } .current-brapi-section{   font-weight: bolder;   border-radius: 5px;    background-color: #ddd; } .brapi-section{   padding: 5px 5px;  } .brapi-section-description{   margin: 5px 0 0 5px; } </style>
 *
 * OpenAPI spec version: 2.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package org.brapi.client.v2.modules.phenotype;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;

import org.apache.commons.lang3.tuple.Pair;
import org.brapi.client.v2.ApiCallback;
import org.brapi.client.v2.BrAPIClient;
import org.brapi.client.v2.ApiResponse;
import org.brapi.client.v2.Configuration;
import org.brapi.client.v2.model.exceptions.ApiException;
import org.brapi.client.v2.model.queryParams.phenotype.ObservationUnitQueryParams;
import org.brapi.client.v2.model.queryParams.phenotype.ObservationUnitTableQueryParams;
import org.brapi.v2.model.BrAPIAcceptedSearchResponse;
import org.brapi.v2.model.BrAPIWSMIMEDataTypes;
import org.brapi.v2.model.pheno.BrAPIObservationUnit;
import org.brapi.v2.model.pheno.response.BrAPIObservationLevelListResponse;
import org.brapi.v2.model.pheno.response.BrAPIObservationUnitListResponse;
import org.brapi.v2.model.pheno.request.BrAPIObservationUnitSearchRequest;
import org.brapi.v2.model.pheno.response.BrAPIObservationUnitSingleResponse;
import org.brapi.v2.model.pheno.response.BrAPIObservationUnitTableResponse;

import com.google.gson.reflect.TypeToken;

import okhttp3.Call;

public class ObservationUnitsApi {
    private BrAPIClient apiClient;

    public ObservationUnitsApi() {
        this(Configuration.getDefaultApiClient());
    }

    public ObservationUnitsApi(BrAPIClient apiClient) {
        this.apiClient = apiClient;
    }

    public BrAPIClient getApiClient() {
        return apiClient;
    }

    public void setApiClient(BrAPIClient apiClient) {
        this.apiClient = apiClient;
    }

    /**
     * Build call for observationlevelsGet
     * @param studyDbId Filter by study DbId (optional)
     * @param trialDbId Filter by trial DbId (optional)
     * @param programDbId Filter by program DbId (optional)
     * @param page Used to request a specific page of data to be returned.  The page indexing starts at 0 (the first page is &#x27;page&#x27;&#x3D; 0). Default is &#x60;0&#x60;. (optional)
     * @param pageSize The size of the pages to be returned. Default is &#x60;1000&#x60;. (optional)



     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    private Call observationlevelsGetCall(String studyDbId, String trialDbId, String programDbId, Integer page, Integer pageSize) throws ApiException {
        Object localVarPostBody = null;
        
        // create path and map variables
        String localVarPath = "/observationlevels";

        Map<String, String> localVarQueryParams = new HashMap<>();
        Map<String, String> localVarCollectionQueryParams = new HashMap<>();
        if (studyDbId != null)
            apiClient.prepQueryParameter(localVarQueryParams, "studyDbId", studyDbId);
        if (trialDbId != null)
            apiClient.prepQueryParameter(localVarQueryParams, "trialDbId", trialDbId);
        if (programDbId != null)
            apiClient.prepQueryParameter(localVarQueryParams, "programDbId", programDbId);
        if (page != null)
            apiClient.prepQueryParameter(localVarQueryParams, "page", page);
        if (pageSize != null)
            apiClient.prepQueryParameter(localVarQueryParams, "pageSize", pageSize);

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        
        

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] { "AuthorizationToken" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames);
    }

    /**
     * Get the Observation Levels
     * Call to retrieve the list of supported observation levels.   Observation levels indicate the granularity level at which the measurements are taken. &#x60;levelName&#x60; defines the level, &#x60;levelOrder&#x60; defines where that level exists in the hierarchy of levels. &#x60;levelOrder&#x60;s lower numbers are at the top of the hierarchy (ie field &gt; 0) and higher numbers are at the bottom of the hierarchy (ie plant &gt; 6).   The values are used to supply the &#x60;observationLevel&#x60; parameter in the observation unit details call.
     * @param studyDbId Filter by study DbId (optional)
     * @param trialDbId Filter by trial DbId (optional)
     * @param programDbId Filter by program DbId (optional)
     * @param page Used to request a specific page of data to be returned.  The page indexing starts at 0 (the first page is &#x27;page&#x27;&#x3D; 0). Default is &#x60;0&#x60;. (optional)
     * @param pageSize The size of the pages to be returned. Default is &#x60;1000&#x60;. (optional)

     * @return ApiResponse&lt;ObservationLevelListResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<BrAPIObservationLevelListResponse> observationlevelsGet(String studyDbId, String trialDbId, String programDbId, Integer page, Integer pageSize) throws ApiException {
        Call call = observationlevelsGetCall(studyDbId, trialDbId, programDbId, page, pageSize);
        Type localVarReturnType = new TypeToken<BrAPIObservationLevelListResponse>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Get the Observation Levels (asynchronously)
     * Call to retrieve the list of supported observation levels.   Observation levels indicate the granularity level at which the measurements are taken. &#x60;levelName&#x60; defines the level, &#x60;levelOrder&#x60; defines where that level exists in the hierarchy of levels. &#x60;levelOrder&#x60;s lower numbers are at the top of the hierarchy (ie field &gt; 0) and higher numbers are at the bottom of the hierarchy (ie plant &gt; 6).   The values are used to supply the &#x60;observationLevel&#x60; parameter in the observation unit details call.
     * @param studyDbId Filter by study DbId (optional)
     * @param trialDbId Filter by trial DbId (optional)
     * @param programDbId Filter by program DbId (optional)
     * @param page Used to request a specific page of data to be returned.  The page indexing starts at 0 (the first page is &#x27;page&#x27;&#x3D; 0). Default is &#x60;0&#x60;. (optional)
     * @param pageSize The size of the pages to be returned. Default is &#x60;1000&#x60;. (optional)

     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public Call observationlevelsGetAsync(String studyDbId, String trialDbId, String programDbId, Integer page, Integer pageSize, final ApiCallback<BrAPIObservationLevelListResponse> callback) throws ApiException {
        Call call = observationlevelsGetCall(studyDbId, trialDbId, programDbId, page, pageSize);
        Type localVarReturnType = new TypeToken<BrAPIObservationLevelListResponse>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for observationunitsGet
     * @param queryParams
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    private Call observationunitsGetCall(ObservationUnitQueryParams queryParams) throws ApiException {
        if(queryParams == null) {
        	throw new IllegalArgumentException("queryParams cannot be null");
        }
        Object localVarPostBody = null;
        
        // create path and map variables
        String localVarPath = "/observationunits";

        Map<String, String> localVarQueryParams = new HashMap<>();
        Map<String, String> localVarCollectionQueryParams = new HashMap<>();
        if (queryParams.observationUnitDbId() != null)
            apiClient.prepQueryParameter(localVarQueryParams, "observationUnitDbId", queryParams.observationUnitDbId());
        if (queryParams.germplasmDbId() != null)
            apiClient.prepQueryParameter(localVarQueryParams, "germplasmDbId", queryParams.germplasmDbId());
        if (queryParams.studyDbId() != null)
            apiClient.prepQueryParameter(localVarQueryParams, "studyDbId", queryParams.studyDbId());
        if (queryParams.locationDbId() != null)
            apiClient.prepQueryParameter(localVarQueryParams, "locationDbId", queryParams.locationDbId());
        if (queryParams.trialDbId() != null)
            apiClient.prepQueryParameter(localVarQueryParams, "trialDbId", queryParams.trialDbId());
        if (queryParams.programDbId() != null)
            apiClient.prepQueryParameter(localVarQueryParams, "programDbId", queryParams.programDbId());
        if (queryParams.seasonDbId() != null)
            apiClient.prepQueryParameter(localVarQueryParams, "seasonDbId", queryParams.seasonDbId());
        if (queryParams.observationUnitLevelName() != null)
            apiClient.prepQueryParameter(localVarQueryParams, "observationUnitLevelName", queryParams.observationUnitLevelName());
        if (queryParams.observationUnitLevelOrder() != null)
            apiClient.prepQueryParameter(localVarQueryParams, "observationUnitLevelOrder", queryParams.observationUnitLevelOrder());
        if (queryParams.observationUnitLevelCode() != null)
            apiClient.prepQueryParameter(localVarQueryParams, "observationUnitLevelCode", queryParams.observationUnitLevelCode());
        if (queryParams.includeObservations() != null)
            apiClient.prepQueryParameter(localVarQueryParams, "includeObservations", queryParams.includeObservations());
        if (queryParams.externalReferenceID() != null) {
            apiClient.prepQueryParameter(localVarQueryParams, "externalReferenceId", queryParams.externalReferenceID());
            apiClient.prepQueryParameter(localVarQueryParams, "externalReferenceID", queryParams.externalReferenceID());
        }
        if (queryParams.externalReferenceSource() != null)
            apiClient.prepQueryParameter(localVarQueryParams, "externalReferenceSource", queryParams.externalReferenceSource());
        if (queryParams.page() != null)
            apiClient.prepQueryParameter(localVarQueryParams, "page", queryParams.page());
        if (queryParams.pageSize() != null)
            apiClient.prepQueryParameter(localVarQueryParams, "pageSize", queryParams.pageSize());

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        
        

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] { "AuthorizationToken" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames);
    }

    /**
     * Get a filtered set of Observation Units
     * Get a filtered set of Observation Units
     * @param queryParams
     * @return ApiResponse&lt;ObservationUnitListResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<BrAPIObservationUnitListResponse> observationunitsGet(ObservationUnitQueryParams queryParams) throws ApiException {
        Call call = observationunitsGetCall(queryParams);
        Type localVarReturnType = new TypeToken<BrAPIObservationUnitListResponse>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Get a filtered set of Observation Units (asynchronously)
     * Get a filtered set of Observation Units
     * @param queryParams
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public Call observationunitsGetAsync(ObservationUnitQueryParams queryParams, final ApiCallback<BrAPIObservationUnitListResponse> callback) throws ApiException {
        Call call = observationunitsGetCall(queryParams);
        Type localVarReturnType = new TypeToken<BrAPIObservationUnitListResponse>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for observationunitsObservationUnitDbIdGet
     * @param observationUnitDbId The unique ID of the specific Observation Unit (required)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    private Call observationunitsObservationUnitDbIdGetCall(String observationUnitDbId) throws ApiException {
        if(observationUnitDbId == null) {
        	throw new IllegalArgumentException("observationUnitDbId cannot be null");
        }
        Object localVarPostBody = null;
        
        // create path and map variables
        String localVarPath = "/observationunits/{observationUnitDbId}"
            .replaceAll("\\{" + "observationUnitDbId" + "\\}", apiClient.escapeString(observationUnitDbId));

        Map<String, String> localVarQueryParams = new HashMap<>();
        Map<String, String> localVarCollectionQueryParams = new HashMap<>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        
        

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] { "AuthorizationToken" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames);
    }

    /**
     * Get the details of a specific Observation Unit
     * Get the details of a specific Observation Unit
     * @param observationUnitDbId The unique ID of the specific Observation Unit (required)

     * @return ApiResponse&lt;ObservationUnitSingleResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<BrAPIObservationUnitSingleResponse> observationunitsObservationUnitDbIdGet(String observationUnitDbId) throws ApiException {
        Call call = observationunitsObservationUnitDbIdGetCall(observationUnitDbId);
        Type localVarReturnType = new TypeToken<BrAPIObservationUnitSingleResponse>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Get the details of a specific Observation Unit (asynchronously)
     * Get the details of a specific Observation Unit
     * @param observationUnitDbId The unique ID of the specific Observation Unit (required)

     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public Call observationunitsObservationUnitDbIdGetAsync(String observationUnitDbId, final ApiCallback<BrAPIObservationUnitSingleResponse> callback) throws ApiException {
        Call call = observationunitsObservationUnitDbIdGetCall(observationUnitDbId);
        Type localVarReturnType = new TypeToken<BrAPIObservationUnitSingleResponse>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for observationunitsObservationUnitDbIdPut
     * @param observationUnitDbId The unique ID of the specific Observation Unit (required)
     * @param body  (optional)



     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    private Call observationunitsObservationUnitDbIdPutCall(String observationUnitDbId, BrAPIObservationUnit body) throws ApiException {
        if(observationUnitDbId == null) {
        	throw new IllegalArgumentException("observationUnitDbId cannot be null");
        }
        if(body == null) {
        	throw new IllegalArgumentException("body cannot be null");
        }
        Object localVarPostBody = body;
        
        // create path and map variables
        String localVarPath = "/observationunits/{observationUnitDbId}"
            .replaceAll("\\{" + "observationUnitDbId" + "\\}", apiClient.escapeString(observationUnitDbId));

        Map<String, String> localVarQueryParams = new HashMap<>();
        Map<String, String> localVarCollectionQueryParams = new HashMap<>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        
        

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] { "AuthorizationToken" };
        return apiClient.buildCall(localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames);
    }

    /**
     * Update an existing Observation Units
     * Update an existing Observation Units
     * @param observationUnitDbId The unique ID of the specific Observation Unit (required)
     * @param body  (optional)

     * @return ApiResponse&lt;ObservationUnitSingleResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<BrAPIObservationUnitSingleResponse> observationunitsObservationUnitDbIdPut(String observationUnitDbId, BrAPIObservationUnit body) throws ApiException {
        Call call = observationunitsObservationUnitDbIdPutCall(observationUnitDbId, body);
        Type localVarReturnType = new TypeToken<BrAPIObservationUnitSingleResponse>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Update an existing Observation Units (asynchronously)
     * Update an existing Observation Units
     * @param observationUnitDbId The unique ID of the specific Observation Unit (required)
     * @param body  (optional)

     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public Call observationunitsObservationUnitDbIdPutAsync(String observationUnitDbId, BrAPIObservationUnit body, final ApiCallback<BrAPIObservationUnitSingleResponse> callback) throws ApiException {
        Call call = observationunitsObservationUnitDbIdPutCall(observationUnitDbId, body);
        Type localVarReturnType = new TypeToken<BrAPIObservationUnitSingleResponse>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for observationunitsPost
     * @param body  (optional)



     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    private Call observationunitsPostCall(List<BrAPIObservationUnit> body) throws ApiException {
        if(body == null) {throw new IllegalArgumentException("body cannot be null"); }
        Object localVarPostBody = body;
        
        // create path and map variables
        String localVarPath = "/observationunits";

        Map<String, String> localVarQueryParams = new HashMap<>();
        Map<String, String> localVarCollectionQueryParams = new HashMap<>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        
        

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] { "AuthorizationToken" };
        return apiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames);
    }

    /**
     * Add new Observation Units
     * Add new Observation Units
     * @param body  (optional)

     * @return ApiResponse&lt;ObservationUnitListResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<BrAPIObservationUnitListResponse> observationunitsPost(List<BrAPIObservationUnit> body) throws ApiException {
        Call call = observationunitsPostCall(body);
        Type localVarReturnType = new TypeToken<BrAPIObservationUnitListResponse>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Add new Observation Units (asynchronously)
     * Add new Observation Units
     * @param body  (optional)

     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public Call observationunitsPostAsync(List<BrAPIObservationUnit> body, final ApiCallback<BrAPIObservationUnitListResponse> callback) throws ApiException {
        Call call = observationunitsPostCall(body);
        Type localVarReturnType = new TypeToken<BrAPIObservationUnitListResponse>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for observationunitsPut
     * @param body  (optional)



     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    private Call observationunitsPutCall(Map<String, BrAPIObservationUnit> body) throws ApiException {
        if(body == null) {
        	throw new IllegalArgumentException("body cannot be null");
        }
        Object localVarPostBody = body;
        
        // create path and map variables
        String localVarPath = "/observationunits";

        Map<String, String> localVarQueryParams = new HashMap<>();
        Map<String, String> localVarCollectionQueryParams = new HashMap<>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        
        

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] { "AuthorizationToken" };
        return apiClient.buildCall(localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames);
    }

    /**
     * Update a set of Observation Units
     * Update a set of Observation Units  Note - In strictly typed languages, this structure can be represented as a Map or Dictionary of objects and parsed directly to JSON.
     * @param body  (optional)

     * @return ApiResponse&lt;ObservationUnitListResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<BrAPIObservationUnitListResponse> observationunitsPut(Map<String, BrAPIObservationUnit> body) throws ApiException {
        Call call = observationunitsPutCall(body);
        Type localVarReturnType = new TypeToken<BrAPIObservationUnitListResponse>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Update a set of Observation Units (asynchronously)
     * Update a set of Observation Units  Note - In strictly typed languages, this structure can be represented as a Map or Dictionary of objects and parsed directly to JSON.
     * @param body  (optional)

     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public Call observationunitsPutAsync(Map<String, BrAPIObservationUnit> body, final ApiCallback<BrAPIObservationUnitListResponse> callback) throws ApiException {
        Call call = observationunitsPutCall(body);
        Type localVarReturnType = new TypeToken<BrAPIObservationUnitListResponse>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for observationunitsTableGet
     * @param queryParams
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    private Call observationunitsTableGetCall(BrAPIWSMIMEDataTypes accept, ObservationUnitTableQueryParams queryParams) throws ApiException {
        if(queryParams == null) {
        	throw new IllegalArgumentException("queryParams cannot be null");
        }
        Object localVarPostBody = null;
        
        // create path and map variables
        String localVarPath = "/observationunits/table";

        Map<String, String> localVarQueryParams = new HashMap<>();
        Map<String, String> localVarCollectionQueryParams = new HashMap<>();
        if (queryParams.observationUnitDbId() != null)
            apiClient.prepQueryParameter(localVarQueryParams, "observationUnitDbId", queryParams.observationUnitDbId());
        if (queryParams.germplasmDbId() != null)
            apiClient.prepQueryParameter(localVarQueryParams, "germplasmDbId", queryParams.germplasmDbId());
        if (queryParams.observationVariableDbId() != null)
            apiClient.prepQueryParameter(localVarQueryParams, "observationVariableDbId", queryParams.observationVariableDbId());
        if (queryParams.studyDbId() != null)
            apiClient.prepQueryParameter(localVarQueryParams, "studyDbId", queryParams.studyDbId());
        if (queryParams.locationDbId() != null)
            apiClient.prepQueryParameter(localVarQueryParams, "locationDbId", queryParams.locationDbId());
        if (queryParams.trialDbId() != null)
            apiClient.prepQueryParameter(localVarQueryParams, "trialDbId", queryParams.trialDbId());
        if (queryParams.programDbId() != null)
            apiClient.prepQueryParameter(localVarQueryParams, "programDbId", queryParams.programDbId());
        if (queryParams.seasonDbId() != null)
            apiClient.prepQueryParameter(localVarQueryParams, "seasonDbId", queryParams.seasonDbId());
        if (queryParams.observationLevel() != null)
            apiClient.prepQueryParameter(localVarQueryParams, "observationLevel", queryParams.observationLevel());

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        if (accept != null)
        localVarHeaderParams.put("Accept", apiClient.parameterToString(accept));
        
        

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json", "text/csv", "text/tsv"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] { "AuthorizationToken" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames);
    }

    /**
     * Get a list of Observations in a table format
     * &lt;p&gt;This service is designed to retrieve a table for observation values as a matrix of Observation Units and Observation Variables.&lt;/p&gt; &lt;p&gt;The table may be represented by JSON, CSV, or TSV. The \&quot;Accept\&quot; HTTP header is used for the client to request different return formats.  By default, if the \&quot;Accept\&quot; header is not included in the request, the server should return JSON as described below.&lt;/p&gt; &lt;p&gt;The table is REQUIRED to have the following columns&lt;/p&gt; &lt;ul&gt;   &lt;li&gt;observationUnitDbId - Each row is related to one Observation Unit&lt;/li&gt;   &lt;li&gt;At least one column with an observationVariableDbId&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;The table may have any or all of the following OPTIONAL columns. Included columns are decided by the server developer&lt;/p&gt; &lt;ul&gt;   &lt;li&gt;observationUnitName&lt;/li&gt;   &lt;li&gt;studyDbId&lt;/li&gt;   &lt;li&gt;studyName&lt;/li&gt;   &lt;li&gt;germplasmDbId&lt;/li&gt;   &lt;li&gt;germplasmName&lt;/li&gt;   &lt;li&gt;positionCoordinateX&lt;/li&gt;   &lt;li&gt;positionCoordinateY&lt;/li&gt;   &lt;li&gt;year&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;The table also may have any number of Observation Unit Hierarchy Level columns. For example:&lt;/p&gt; &lt;ul&gt;   &lt;li&gt;field&lt;/li&gt;   &lt;li&gt;plot&lt;/li&gt;   &lt;li&gt;sub-plot&lt;/li&gt;   &lt;li&gt;plant&lt;/li&gt;   &lt;li&gt;pot&lt;/li&gt;   &lt;li&gt;block&lt;/li&gt;   &lt;li&gt;entry&lt;/li&gt;   &lt;li&gt;rep&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;The JSON representation provides a pair of extra arrays for defining the headers of the table.  The first array \&quot;headerRow\&quot; will always contain \&quot;observationUnitDbId\&quot; and any or all of the OPTIONAL column header names.  The second array \&quot;observationVariables\&quot; contains the names and DbIds for the Observation Variables represented in the table.  By appending the two arrays, you can construct the complete header row of the table. &lt;/p&gt; &lt;p&gt;For CSV and TSV representations of the table, an extra header row is needed to describe both the Observation Variable DbId and the Observation Variable Name for each data column.  See the example responses below&lt;/p&gt; 
     * @param queryParams
     * @return ApiResponse&lt;ObservationUnitTableResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<BrAPIObservationUnitTableResponse> observationunitsTableGet(BrAPIWSMIMEDataTypes accept, ObservationUnitTableQueryParams queryParams) throws ApiException {
        Call call = observationunitsTableGetCall(accept, queryParams);
        Type localVarReturnType = new TypeToken<BrAPIObservationUnitTableResponse>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Get a list of Observations in a table format (asynchronously)
     * &lt;p&gt;This service is designed to retrieve a table for observation values as a matrix of Observation Units and Observation Variables.&lt;/p&gt; &lt;p&gt;The table may be represented by JSON, CSV, or TSV. The \&quot;Accept\&quot; HTTP header is used for the client to request different return formats.  By default, if the \&quot;Accept\&quot; header is not included in the request, the server should return JSON as described below.&lt;/p&gt; &lt;p&gt;The table is REQUIRED to have the following columns&lt;/p&gt; &lt;ul&gt;   &lt;li&gt;observationUnitDbId - Each row is related to one Observation Unit&lt;/li&gt;   &lt;li&gt;At least one column with an observationVariableDbId&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;The table may have any or all of the following OPTIONAL columns. Included columns are decided by the server developer&lt;/p&gt; &lt;ul&gt;   &lt;li&gt;observationUnitName&lt;/li&gt;   &lt;li&gt;studyDbId&lt;/li&gt;   &lt;li&gt;studyName&lt;/li&gt;   &lt;li&gt;germplasmDbId&lt;/li&gt;   &lt;li&gt;germplasmName&lt;/li&gt;   &lt;li&gt;positionCoordinateX&lt;/li&gt;   &lt;li&gt;positionCoordinateY&lt;/li&gt;   &lt;li&gt;year&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;The table also may have any number of Observation Unit Hierarchy Level columns. For example:&lt;/p&gt; &lt;ul&gt;   &lt;li&gt;field&lt;/li&gt;   &lt;li&gt;plot&lt;/li&gt;   &lt;li&gt;sub-plot&lt;/li&gt;   &lt;li&gt;plant&lt;/li&gt;   &lt;li&gt;pot&lt;/li&gt;   &lt;li&gt;block&lt;/li&gt;   &lt;li&gt;entry&lt;/li&gt;   &lt;li&gt;rep&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;The JSON representation provides a pair of extra arrays for defining the headers of the table.  The first array \&quot;headerRow\&quot; will always contain \&quot;observationUnitDbId\&quot; and any or all of the OPTIONAL column header names.  The second array \&quot;observationVariables\&quot; contains the names and DbIds for the Observation Variables represented in the table.  By appending the two arrays, you can construct the complete header row of the table. &lt;/p&gt; &lt;p&gt;For CSV and TSV representations of the table, an extra header row is needed to describe both the Observation Variable DbId and the Observation Variable Name for each data column.  See the example responses below&lt;/p&gt; 
     * @param queryParams
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public Call observationunitsTableGetAsync(BrAPIWSMIMEDataTypes accept, ObservationUnitTableQueryParams queryParams, final ApiCallback<BrAPIObservationUnitTableResponse> callback) throws ApiException {
        Call call = observationunitsTableGetCall(accept, queryParams);
        Type localVarReturnType = new TypeToken<BrAPIObservationUnitTableResponse>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for searchObservationunitsPost
     * @param body  (optional)



     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    private Call searchObservationunitsPostCall(BrAPIObservationUnitSearchRequest body) throws ApiException {
        if(body == null) {
        	throw new IllegalArgumentException("body cannot be null");
        }
        Object localVarPostBody = body;
        
        // create path and map variables
        String localVarPath = "/search/observationunits";

        Map<String, String> localVarQueryParams = new HashMap<>();
        Map<String, String> localVarCollectionQueryParams = new HashMap<>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        
        

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] { "AuthorizationToken" };
        return apiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames);
    }

    /**
     * Submit a search request for Observation Units
     * Returns a list of observationUnit with the observed Phenotypes.  See Search Services for additional implementation details.  Use case - this section allows to get a dataset from multiple studies. It allows to integrate data from several databases.  Example Use cases   - Study a panel of germplasm across multiple studies  - Get all data for a specific study   - Get simple atomic phenotyping values   - Study Locations for adaptation to climate change  - Find phenotypes that are from after a certain timestamp  observationTimeStampRangeStart and observationTimeStampRangeEnd use Iso Standard 8601.  observationValue data type inferred from the ontology
     * @param body  (optional)

     * @return ApiResponse&lt;ObservationUnitListResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<Pair<Optional<BrAPIObservationUnitListResponse>, Optional<BrAPIAcceptedSearchResponse>>> searchObservationunitsPost(BrAPIObservationUnitSearchRequest body) throws ApiException {
        Call call = searchObservationunitsPostCall(body);
        Type localVarReturnType = new TypeToken<BrAPIObservationUnitListResponse>(){}.getType();
        return apiClient.executeSearch(call, localVarReturnType);
    }

    /**
     * Submit a search request for Observation Units (asynchronously)
     * Returns a list of observationUnit with the observed Phenotypes.  See Search Services for additional implementation details.  Use case - this section allows to get a dataset from multiple studies. It allows to integrate data from several databases.  Example Use cases   - Study a panel of germplasm across multiple studies  - Get all data for a specific study   - Get simple atomic phenotyping values   - Study Locations for adaptation to climate change  - Find phenotypes that are from after a certain timestamp  observationTimeStampRangeStart and observationTimeStampRangeEnd use Iso Standard 8601.  observationValue data type inferred from the ontology
     * @param body  (optional)

     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public Call searchObservationunitsPostAsync(BrAPIObservationUnitSearchRequest body, final ApiCallback<BrAPIObservationUnitListResponse> callback) throws ApiException {
        Call call = searchObservationunitsPostCall(body);
        Type localVarReturnType = new TypeToken<BrAPIObservationUnitListResponse>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for searchObservationunitsSearchResultsDbIdGet
     * @param searchResultsDbId Unique identifier which references the search results (required)
     * @param page Used to request a specific page of data to be returned.  The page indexing starts at 0 (the first page is &#x27;page&#x27;&#x3D; 0). Default is &#x60;0&#x60;. (optional)
     * @param pageSize The size of the pages to be returned. Default is &#x60;1000&#x60;. (optional)



     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    private Call searchObservationunitsSearchResultsDbIdGetCall(String searchResultsDbId, Integer page, Integer pageSize) throws ApiException {
        if(searchResultsDbId == null) {
        	throw new IllegalArgumentException("searchResultsDbId cannot be null");
        }
        Object localVarPostBody = null;
        
        // create path and map variables
        String localVarPath = "/search/observationunits/{searchResultsDbId}"
            .replaceAll("\\{" + "searchResultsDbId" + "\\}", apiClient.escapeString(searchResultsDbId));

        Map<String, String> localVarQueryParams = new HashMap<>();
        Map<String, String> localVarCollectionQueryParams = new HashMap<>();
        if (page != null)
            apiClient.prepQueryParameter(localVarQueryParams, "page", page);
        if (pageSize != null)
            apiClient.prepQueryParameter(localVarQueryParams, "pageSize", pageSize);

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        
        

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] { "AuthorizationToken" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames);
    }

    /**
     * Observation Unit Search
     * Returns a list of observationUnit with the observed Phenotypes.  See Search Services for additional implementation details.
     * @param searchResultsDbId Unique identifier which references the search results (required)
     * @param page Used to request a specific page of data to be returned.  The page indexing starts at 0 (the first page is &#x27;page&#x27;&#x3D; 0). Default is &#x60;0&#x60;. (optional)
     * @param pageSize The size of the pages to be returned. Default is &#x60;1000&#x60;. (optional)

     * @return ApiResponse&lt;ObservationUnitListResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<Pair<Optional<BrAPIObservationUnitListResponse>, Optional<BrAPIAcceptedSearchResponse>>> searchObservationunitsSearchResultsDbIdGet(String searchResultsDbId, Integer page, Integer pageSize) throws ApiException {
        Call call = searchObservationunitsSearchResultsDbIdGetCall(searchResultsDbId, page, pageSize);
        Type localVarReturnType = new TypeToken<BrAPIObservationUnitListResponse>(){}.getType();
        return apiClient.executeSearch(call, localVarReturnType);
    }

    /**
     * Observation Unit Search (asynchronously)
     * Returns a list of observationUnit with the observed Phenotypes.  See Search Services for additional implementation details.
     * @param searchResultsDbId Unique identifier which references the search results (required)
     * @param page Used to request a specific page of data to be returned.  The page indexing starts at 0 (the first page is &#x27;page&#x27;&#x3D; 0). Default is &#x60;0&#x60;. (optional)
     * @param pageSize The size of the pages to be returned. Default is &#x60;1000&#x60;. (optional)

     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public Call searchObservationunitsSearchResultsDbIdGetAsync(String searchResultsDbId, Integer page, Integer pageSize, final ApiCallback<BrAPIObservationUnitListResponse> callback) throws ApiException {
        Call call = searchObservationunitsSearchResultsDbIdGetCall(searchResultsDbId, page, pageSize);
        Type localVarReturnType = new TypeToken<BrAPIObservationUnitListResponse>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
}
