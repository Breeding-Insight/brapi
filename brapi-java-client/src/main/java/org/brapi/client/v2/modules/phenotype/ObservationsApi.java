/*
 * BrAPI-Phenotyping
 * The Breeding API (BrAPI) is a Standardized REST ful Web Service API Specification for communicating Plant Breeding Data. BrAPI allows for easy data sharing between databases and tools involved in plant breeding. <div class=\"brapi-section\"> <h2 class=\"brapi-section-title\">General Reference Documentation</h2> <div class=\"gen-info-link\"><a href=\"https://github.com/plantbreeding/API/blob/master/Specification/GeneralInfo/URL_Structure.md\">URL Structure</a></div> <div class=\"gen-info-link\"><a href=\"https://github.com/plantbreeding/API/blob/master/Specification/GeneralInfo/Response_Structure.md\">Response Structure</a></div> <div class=\"gen-info-link\"><a href=\"https://github.com/plantbreeding/API/blob/master/Specification/GeneralInfo/Date_Time_Encoding.md\">Date/Time Encoding</a></div> <div class=\"gen-info-link\"><a href=\"https://github.com/plantbreeding/API/blob/master/Specification/GeneralInfo/Location_Encoding.md\">Location Encoding</a></div> <div class=\"gen-info-link\"><a href=\"https://github.com/plantbreeding/API/blob/master/Specification/GeneralInfo/Error_Handling.md\">Error Handling</a></div> <div class=\"gen-info-link\"><a href=\"https://github.com/plantbreeding/API/blob/master/Specification/GeneralInfo/Search_Services.md\">Search Services</a></div> </div>  <div class=\"brapi-section\"> <h2 class=\"brapi-section-title\">BrAPI Core</h2> <div class=\"brapi-section-description\">The BrAPI Core module contains high level entities used for organization and management. This includes Programs, Trials, Studies, Locations, People, and Lists</div> <div class=\"version-number\">V2.0</div> <div class=\"link-btn\"><a href=\"https://github.com/plantbreeding/API/tree/master/Specification/BrAPI-Core\">GitHub</a></div> <div class=\"link-btn\"><a href=\"https://app.swaggerhub.com/apis/PlantBreedingAPI/BrAPI-Core\">SwaggerHub</a></div> <div class=\"link-btn\"><a href=\"https://brapicore.docs.apiary.io\">Apiary</a></div> <div class=\"stop-float\"></div> </div>  <div class=\"current-brapi-section brapi-section\"> <h2 class=\"brapi-section-title\">BrAPI Phenotyping</h2> <div class=\"brapi-section-description\">The BrAPI Phenotyping module contains entities related to phenotypic observations. This includes Observation Units, Observations, Observation Variables, Traits, Scales, Methods, and Images</div> <div class=\"version-number\">V2.0</div> <div class=\"link-btn\"><a href=\"https://github.com/plantbreeding/API/tree/master/Specification/BrAPI-Phenotyping\">GitHub</a></div> <div class=\"link-btn\"><a href=\"https://app.swaggerhub.com/apis/PlantBreedingAPI/BrAPI-Phenotyping\">SwaggerHub</a></div> <div class=\"link-btn\"><a href=\"https://brapiphenotyping.docs.apiary.io\">Apiary</a></div> <div class=\"stop-float\"></div> </div>  <div class=\"brapi-section\"> <h2 class=\"brapi-section-title\">BrAPI Genotyping</h2> <div class=\"brapi-section-description\">The BrAPI Genotyping module contains entities related to genotyping analysis. This includes Samples, Markers, Variant Sets, Variants, Call Sets, Calls, References, Reads, and Vendor Orders</div> <div class=\"version-number\">V2.0</div> <div class=\"link-btn\"><a href=\"https://github.com/plantbreeding/API/tree/master/Specification/BrAPI-Genotyping\">GitHub</a></div> <div class=\"link-btn\"><a href=\"https://app.swaggerhub.com/apis/PlantBreedingAPI/BrAPI-Genotyping\">SwaggerHub</a></div> <div class=\"link-btn\"><a href=\"https://brapigenotyping.docs.apiary.io\">Apiary</a></div> <div class=\"stop-float\"></div> </div>  <div class=\"brapi-section\"> <h2 class=\"brapi-section-title\">BrAPI Germplasm</h2> <div class=\"brapi-section-description\">The BrAPI Germplasm module contains entities related to germplasm management. This includes Germplasm, Germplasm Attributes, Seed Lots, Crosses, Pedigree, and Progeny</div> <div class=\"version-number\">V2.0</div> <div class=\"link-btn\"><a href=\"https://github.com/plantbreeding/API/tree/master/Specification/BrAPI-Germplasm\">GitHub</a></div> <div class=\"link-btn\"><a href=\"https://app.swaggerhub.com/apis/PlantBreedingAPI/BrAPI-Germplasm\">SwaggerHub</a></div> <div class=\"link-btn\"><a href=\"https://brapigermplasm.docs.apiary.io\">Apiary</a></div> <div class=\"stop-float\"></div> </div>  <style> .link-btn{ float: left;  margin: 2px 10px 0 0;  padding: 0 5px;  border-radius: 5px;  background-color: #ddd; } .stop-float{   clear: both; } .version-number{   float: left;    margin: 5px 10px 0 5px; } .brapi-section-title{   margin: 0 10px 0 0;   font-size: 20px; } .current-brapi-section{   font-weight: bolder;   border-radius: 5px;    background-color: #ddd; } .brapi-section{   padding: 5px 5px;  } .brapi-section-description{   margin: 5px 0 0 5px; } </style>
 *
 * OpenAPI spec version: 2.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package org.brapi.client.v2.modules.phenotype;

import okhttp3.Call;
import com.google.gson.reflect.TypeToken;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.brapi.client.v2.ApiCallback;
import org.brapi.client.v2.ApiClient;
import org.brapi.client.v2.ApiResponse;
import org.brapi.client.v2.Configuration;
import org.brapi.client.v2.model.exceptions.ApiException;
import org.brapi.client.v2.model.queryParams.phenotype.ObservationQueryParams;
import org.brapi.client.v2.model.queryParams.phenotype.ObservationTableQueryParams;
import org.brapi.v2.model.WSMIMEDataTypes;
import org.brapi.v2.model.pheno.ObservationListResponse;
import org.brapi.v2.model.pheno.ObservationNewRequest;
import org.brapi.v2.model.pheno.ObservationSearchRequest;
import org.brapi.v2.model.pheno.ObservationSingleResponse;
import org.brapi.v2.model.pheno.ObservationTableResponse;

public class ObservationsApi {
    private ApiClient apiClient;

    public ObservationsApi() {
        this(Configuration.getDefaultApiClient());
    }

    public ObservationsApi(ApiClient apiClient) {
        this.apiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return apiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.apiClient = apiClient;
    }

    /**
     * Build call for observationsGet
     * @param queryParams
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    private Call observationsGetCall(ObservationQueryParams queryParams) throws ApiException {
        Object localVarPostBody = null;
        
        // create path and map variables
        String localVarPath = "/observations";

        Map<String, String> localVarQueryParams = new HashMap<>();
        Map<String, String> localVarCollectionQueryParams = new HashMap<>();
        if (queryParams.observationDbId() != null)
            apiClient.prepQueryParameter(localVarQueryParams, "observationDbId", queryParams.observationDbId());
        if (queryParams.observationUnitDbId() != null)
            apiClient.prepQueryParameter(localVarQueryParams, "observationUnitDbId", queryParams.observationUnitDbId());
        if (queryParams.germplasmDbId() != null)
            apiClient.prepQueryParameter(localVarQueryParams, "germplasmDbId", queryParams.germplasmDbId());
        if (queryParams.observationVariableDbId() != null)
            apiClient.prepQueryParameter(localVarQueryParams, "observationVariableDbId", queryParams.observationVariableDbId());
        if (queryParams.studyDbId() != null)
            apiClient.prepQueryParameter(localVarQueryParams, "studyDbId", queryParams.studyDbId());
        if (queryParams.locationDbId() != null)
            apiClient.prepQueryParameter(localVarQueryParams, "locationDbId", queryParams.locationDbId());
        if (queryParams.trialDbId() != null)
            apiClient.prepQueryParameter(localVarQueryParams, "trialDbId", queryParams.trialDbId());
        if (queryParams.programDbId() != null)
            apiClient.prepQueryParameter(localVarQueryParams, "programDbId", queryParams.programDbId());
        if (queryParams.seasonDbId() != null)
            apiClient.prepQueryParameter(localVarQueryParams, "seasonDbId", queryParams.seasonDbId());
        if (queryParams.observationUnitLevelName() != null)
            apiClient.prepQueryParameter(localVarQueryParams, "observationUnitLevelName", queryParams.observationUnitLevelName());
        if (queryParams.observationUnitLevelOrder() != null)
            apiClient.prepQueryParameter(localVarQueryParams, "observationUnitLevelOrder", queryParams.observationUnitLevelOrder());
        if (queryParams.observationUnitLevelCode() != null)
            apiClient.prepQueryParameter(localVarQueryParams, "observationUnitLevelCode", queryParams.observationUnitLevelCode());
        if (queryParams.observationTimeStampRangeStart() != null)
            apiClient.prepQueryParameter(localVarQueryParams, "observationTimeStampRangeStart", queryParams.observationTimeStampRangeStart());
        if (queryParams.observationTimeStampRangeEnd() != null)
            apiClient.prepQueryParameter(localVarQueryParams, "observationTimeStampRangeEnd", queryParams.observationTimeStampRangeEnd());
        if (queryParams.externalReferenceID() != null)
            apiClient.prepQueryParameter(localVarQueryParams, "externalReferenceID", queryParams.externalReferenceID());
        if (queryParams.externalReferenceSource() != null)
            apiClient.prepQueryParameter(localVarQueryParams, "externalReferenceSource", queryParams.externalReferenceSource());
        if (queryParams.page() != null)
            apiClient.prepQueryParameter(localVarQueryParams, "page", queryParams.page());
        if (queryParams.pageSize() != null)
            apiClient.prepQueryParameter(localVarQueryParams, "pageSize", queryParams.pageSize());

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        
        

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] { "AuthorizationToken" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames);
    }

    /**
     * Get a filtered set of Observations
     * Retrieve all observations where there are measurements for the given observation variables.  observationTimestamp should be ISO8601 format with timezone -&gt; YYYY-MM-DDThh:mm:ss+hhmm
     * @param queryParams
     * @return ApiResponse&lt;ObservationListResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<ObservationListResponse> observationsGet(ObservationQueryParams queryParams) throws ApiException {
        Call call = observationsGetCall(queryParams);
        Type localVarReturnType = new TypeToken<ObservationListResponse>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Get a filtered set of Observations (asynchronously)
     * Retrieve all observations where there are measurements for the given observation variables.  observationTimestamp should be ISO8601 format with timezone -&gt; YYYY-MM-DDThh:mm:ss+hhmm
     * @param queryParams
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public Call observationsGetAsync(ObservationQueryParams queryParams, final ApiCallback<ObservationListResponse> callback) throws ApiException {
        Call call = observationsGetCall(queryParams);
        Type localVarReturnType = new TypeToken<ObservationListResponse>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for observationsObservationDbIdGet
     * @param observationDbId The unique ID of an observation (required)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    private Call observationsObservationDbIdGetCall(String observationDbId) throws ApiException {
        Object localVarPostBody = null;
        
        // create path and map variables
        String localVarPath = "/observations/{observationDbId}"
            .replaceAll("\\{" + "observationDbId" + "\\}", apiClient.escapeString(observationDbId.toString()));

        Map<String, String> localVarQueryParams = new HashMap<>();
        Map<String, String> localVarCollectionQueryParams = new HashMap<>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        
        

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] { "AuthorizationToken" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames);
    }

    /**
     * Get the details of a specific Observations
     * Get the details of a specific Observations  observationTimestamp should be ISO8601 format with timezone -&gt; YYYY-MM-DDThh:mm:ss+hhmm
     * @param observationDbId The unique ID of an observation (required)

     * @return ApiResponse&lt;ObservationSingleResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<ObservationSingleResponse> observationsObservationDbIdGet(String observationDbId) throws ApiException {
        Call call = observationsObservationDbIdGetCall(observationDbId);
        Type localVarReturnType = new TypeToken<ObservationSingleResponse>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Get the details of a specific Observations (asynchronously)
     * Get the details of a specific Observations  observationTimestamp should be ISO8601 format with timezone -&gt; YYYY-MM-DDThh:mm:ss+hhmm
     * @param observationDbId The unique ID of an observation (required)

     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public Call observationsObservationDbIdGetAsync(String observationDbId, final ApiCallback<ObservationSingleResponse> callback) throws ApiException {
        Call call = observationsObservationDbIdGetCall(observationDbId);
        Type localVarReturnType = new TypeToken<ObservationSingleResponse>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for observationsObservationDbIdPut
     * @param observationDbId The unique ID of an observation (required)
     * @param body  (optional)



     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    private Call observationsObservationDbIdPutCall(String observationDbId, ObservationNewRequest body) throws ApiException {
        Object localVarPostBody = body;
        
        // create path and map variables
        String localVarPath = "/observations/{observationDbId}"
            .replaceAll("\\{" + "observationDbId" + "\\}", apiClient.escapeString(observationDbId.toString()));

        Map<String, String> localVarQueryParams = new HashMap<>();
        Map<String, String> localVarCollectionQueryParams = new HashMap<>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        
        

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] { "AuthorizationToken" };
        return apiClient.buildCall(localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames);
    }

    /**
     * Update an existing Observation
     * Update an existing Observation
     * @param observationDbId The unique ID of an observation (required)
     * @param body  (optional)

     * @return ApiResponse&lt;ObservationSingleResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<ObservationSingleResponse> observationsObservationDbIdPut(String observationDbId, ObservationNewRequest body) throws ApiException {
        Call call = observationsObservationDbIdPutCall(observationDbId, body);
        Type localVarReturnType = new TypeToken<ObservationSingleResponse>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Update an existing Observation (asynchronously)
     * Update an existing Observation
     * @param observationDbId The unique ID of an observation (required)
     * @param body  (optional)

     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public Call observationsObservationDbIdPutAsync(String observationDbId, ObservationNewRequest body, final ApiCallback<ObservationSingleResponse> callback) throws ApiException {
        Call call = observationsObservationDbIdPutCall(observationDbId, body);
        Type localVarReturnType = new TypeToken<ObservationSingleResponse>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for observationsPost
     * @param body  (optional)



     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    private Call observationsPostCall(List<ObservationNewRequest> body) throws ApiException {
        Object localVarPostBody = body;
        
        // create path and map variables
        String localVarPath = "/observations";

        Map<String, String> localVarQueryParams = new HashMap<>();
        Map<String, String> localVarCollectionQueryParams = new HashMap<>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        
        

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] { "AuthorizationToken" };
        return apiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames);
    }

    /**
     * Add new Observation entities
     * Add new Observation entities
     * @param body  (optional)

     * @return ApiResponse&lt;ObservationListResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<ObservationListResponse> observationsPost(List<ObservationNewRequest> body) throws ApiException {
        Call call = observationsPostCall(body);
        Type localVarReturnType = new TypeToken<ObservationListResponse>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Add new Observation entities (asynchronously)
     * Add new Observation entities
     * @param body  (optional)

     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public Call observationsPostAsync(List<ObservationNewRequest> body, final ApiCallback<ObservationListResponse> callback) throws ApiException {
        Call call = observationsPostCall(body);
        Type localVarReturnType = new TypeToken<ObservationListResponse>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for observationsPut
     * @param body  (optional)



     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    private Call observationsPutCall(Map<String, ObservationNewRequest> body) throws ApiException {
        Object localVarPostBody = body;
        
        // create path and map variables
        String localVarPath = "/observations";

        Map<String, String> localVarQueryParams = new HashMap<>();
        Map<String, String> localVarCollectionQueryParams = new HashMap<>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        
        

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] { "AuthorizationToken" };
        return apiClient.buildCall(localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames);
    }

    /**
     * Update multiple Observation entities
     * Update multiple Observation entities simultaneously with a single call  Include as many &#x60;observationDbIds&#x60; in the request as needed.  Note - In strictly typed languages, this structure can be represented as a Map or Dictionary of objects and parsed directly from JSON.
     * @param body  (optional)

     * @return ApiResponse&lt;ObservationListResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<ObservationListResponse> observationsPut(Map<String, ObservationNewRequest> body) throws ApiException {
        Call call = observationsPutCall(body);
        Type localVarReturnType = new TypeToken<ObservationListResponse>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Update multiple Observation entities (asynchronously)
     * Update multiple Observation entities simultaneously with a single call  Include as many &#x60;observationDbIds&#x60; in the request as needed.  Note - In strictly typed languages, this structure can be represented as a Map or Dictionary of objects and parsed directly from JSON.
     * @param body  (optional)

     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public Call observationsPutAsync(Map<String, ObservationNewRequest> body, final ApiCallback<ObservationListResponse> callback) throws ApiException {
        Call call = observationsPutCall(body);
        Type localVarReturnType = new TypeToken<ObservationListResponse>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for observationsTableGet
     * @param queryParams
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    private Call observationsTableGetCall(WSMIMEDataTypes accept, ObservationTableQueryParams queryParams) throws ApiException {
        Object localVarPostBody = null;
        
        // create path and map variables
        String localVarPath = "/observations/table";

        Map<String, String> localVarQueryParams = new HashMap<>();
        Map<String, String> localVarCollectionQueryParams = new HashMap<>();
        if (queryParams.observationUnitDbId() != null)
            apiClient.prepQueryParameter(localVarQueryParams, "observationUnitDbId", queryParams.observationUnitDbId());
        if (queryParams.germplasmDbId() != null)
            apiClient.prepQueryParameter(localVarQueryParams, "germplasmDbId", queryParams.germplasmDbId());
        if (queryParams.observationVariableDbId() != null)
            apiClient.prepQueryParameter(localVarQueryParams, "observationVariableDbId", queryParams.observationVariableDbId());
        if (queryParams.studyDbId() != null)
            apiClient.prepQueryParameter(localVarQueryParams, "studyDbId", queryParams.studyDbId());
        if (queryParams.locationDbId() != null)
            apiClient.prepQueryParameter(localVarQueryParams, "locationDbId", queryParams.locationDbId());
        if (queryParams.trialDbId() != null)
            apiClient.prepQueryParameter(localVarQueryParams, "trialDbId", queryParams.trialDbId());
        if (queryParams.programDbId() != null)
            apiClient.prepQueryParameter(localVarQueryParams, "programDbId", queryParams.programDbId());
        if (queryParams.seasonDbId() != null)
            apiClient.prepQueryParameter(localVarQueryParams, "seasonDbId", queryParams.seasonDbId());
        if (queryParams.observationLevel() != null)
            apiClient.prepQueryParameter(localVarQueryParams, "observationLevel", queryParams.observationLevel());
        if (queryParams.searchResultsDbId() != null)
            apiClient.prepQueryParameter(localVarQueryParams, "searchResultsDbId", queryParams.searchResultsDbId());
        if (queryParams.observationTimeStampRangeStart() != null)
            apiClient.prepQueryParameter(localVarQueryParams, "observationTimeStampRangeStart", queryParams.observationTimeStampRangeStart());
        if (queryParams.observationTimeStampRangeEnd() != null)
            apiClient.prepQueryParameter(localVarQueryParams, "observationTimeStampRangeEnd", queryParams.observationTimeStampRangeEnd());

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        if (accept != null)
        localVarHeaderParams.put("Accept", apiClient.parameterToString(accept));
        
        

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json", "text/csv", "text/tsv"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] { "AuthorizationToken" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames);
    }

    /**
     * Get a list of Observations in a table format
     * &lt;p&gt;This service is designed to retrieve a table of time dependant observation values as a matrix of Observation Units and Observation Variables. This is also sometimes called a Time Series. This service takes the \&quot;Sparse Table\&quot; approach for representing this time dependant data.&lt;/p&gt; &lt;p&gt;The table may be represented by JSON, CSV, or TSV. The \&quot;Accept\&quot; HTTP header is used for the client to request different return formats.  By default, if the \&quot;Accept\&quot; header is not included in the request, the server should return JSON as described below.&lt;/p&gt; &lt;p&gt;The table is REQUIRED to have the following columns&lt;/p&gt; &lt;ul&gt;   &lt;li&gt;observationUnitDbId - Each row is related to one Observation Unit&lt;/li&gt;   &lt;li&gt;observationTimeStamp - Each row is has a time stamp for when the observation was taken&lt;/li&gt;   &lt;li&gt;At least one column with an observationVariableDbId&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;The table may have any or all of the following OPTIONAL columns. Included columns are decided by the server developer&lt;/p&gt; &lt;ul&gt;   &lt;li&gt;observationUnitName&lt;/li&gt;   &lt;li&gt;studyDbId&lt;/li&gt;   &lt;li&gt;studyName&lt;/li&gt;   &lt;li&gt;germplasmDbId&lt;/li&gt;   &lt;li&gt;germplasmName&lt;/li&gt;   &lt;li&gt;positionCoordinateX&lt;/li&gt;   &lt;li&gt;positionCoordinateY&lt;/li&gt;   &lt;li&gt;year&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;The table also may have any number of Observation Unit Hierarchy Level columns. For example:&lt;/p&gt; &lt;ul&gt;   &lt;li&gt;field&lt;/li&gt;   &lt;li&gt;plot&lt;/li&gt;   &lt;li&gt;sub-plot&lt;/li&gt;   &lt;li&gt;plant&lt;/li&gt;   &lt;li&gt;pot&lt;/li&gt;   &lt;li&gt;block&lt;/li&gt;   &lt;li&gt;entry&lt;/li&gt;   &lt;li&gt;rep&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;The JSON representation provides a pair of extra arrays for defining the headers of the table.  The first array \&quot;headerRow\&quot; will always contain \&quot;observationUnitDbId\&quot; and any or all of the OPTIONAL column header names.  The second array \&quot;observationVariables\&quot; contains the names and DbIds for the Observation Variables represented in the table.  By appending the two arrays, you can construct the complete header row of the table. &lt;/p&gt; &lt;p&gt;For CSV and TSV representations of the table, an extra header row is needed to describe both the Observation Variable DbId and the Observation Variable Name for each data column.  See the example responses below&lt;/p&gt; 
     * @param queryParams
     * @return ApiResponse&lt;ObservationTableResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<ObservationTableResponse> observationsTableGet(WSMIMEDataTypes accept, ObservationTableQueryParams queryParams) throws ApiException {
        Call call = observationsTableGetCall(accept, queryParams);
        Type localVarReturnType = new TypeToken<ObservationTableResponse>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Get a list of Observations in a table format (asynchronously)
     * &lt;p&gt;This service is designed to retrieve a table of time dependant observation values as a matrix of Observation Units and Observation Variables. This is also sometimes called a Time Series. This service takes the \&quot;Sparse Table\&quot; approach for representing this time dependant data.&lt;/p&gt; &lt;p&gt;The table may be represented by JSON, CSV, or TSV. The \&quot;Accept\&quot; HTTP header is used for the client to request different return formats.  By default, if the \&quot;Accept\&quot; header is not included in the request, the server should return JSON as described below.&lt;/p&gt; &lt;p&gt;The table is REQUIRED to have the following columns&lt;/p&gt; &lt;ul&gt;   &lt;li&gt;observationUnitDbId - Each row is related to one Observation Unit&lt;/li&gt;   &lt;li&gt;observationTimeStamp - Each row is has a time stamp for when the observation was taken&lt;/li&gt;   &lt;li&gt;At least one column with an observationVariableDbId&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;The table may have any or all of the following OPTIONAL columns. Included columns are decided by the server developer&lt;/p&gt; &lt;ul&gt;   &lt;li&gt;observationUnitName&lt;/li&gt;   &lt;li&gt;studyDbId&lt;/li&gt;   &lt;li&gt;studyName&lt;/li&gt;   &lt;li&gt;germplasmDbId&lt;/li&gt;   &lt;li&gt;germplasmName&lt;/li&gt;   &lt;li&gt;positionCoordinateX&lt;/li&gt;   &lt;li&gt;positionCoordinateY&lt;/li&gt;   &lt;li&gt;year&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;The table also may have any number of Observation Unit Hierarchy Level columns. For example:&lt;/p&gt; &lt;ul&gt;   &lt;li&gt;field&lt;/li&gt;   &lt;li&gt;plot&lt;/li&gt;   &lt;li&gt;sub-plot&lt;/li&gt;   &lt;li&gt;plant&lt;/li&gt;   &lt;li&gt;pot&lt;/li&gt;   &lt;li&gt;block&lt;/li&gt;   &lt;li&gt;entry&lt;/li&gt;   &lt;li&gt;rep&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;The JSON representation provides a pair of extra arrays for defining the headers of the table.  The first array \&quot;headerRow\&quot; will always contain \&quot;observationUnitDbId\&quot; and any or all of the OPTIONAL column header names.  The second array \&quot;observationVariables\&quot; contains the names and DbIds for the Observation Variables represented in the table.  By appending the two arrays, you can construct the complete header row of the table. &lt;/p&gt; &lt;p&gt;For CSV and TSV representations of the table, an extra header row is needed to describe both the Observation Variable DbId and the Observation Variable Name for each data column.  See the example responses below&lt;/p&gt; 
     * @param queryParams
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public Call observationsTableGetAsync(WSMIMEDataTypes accept, ObservationTableQueryParams queryParams, final ApiCallback<ObservationListResponse> callback) throws ApiException {
        Call call = observationsTableGetCall(accept, queryParams);
        Type localVarReturnType = new TypeToken<ObservationTableResponse>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for searchObservationsPost
     * @param body  (optional)



     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    private Call searchObservationsPostCall(ObservationSearchRequest body) throws ApiException {
        Object localVarPostBody = body;
        
        // create path and map variables
        String localVarPath = "/search/observations";

        Map<String, String> localVarQueryParams = new HashMap<>();
        Map<String, String> localVarCollectionQueryParams = new HashMap<>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        
        

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] { "AuthorizationToken" };
        return apiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames);
    }

    /**
     * Submit a search request for a set of Observations
     * Submit a search request for a set of Observations. Returns an Id which reference the results of this search
     * @param body  (optional)

     * @return ApiResponse&lt;ObservationListResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<ObservationListResponse> searchObservationsPost(ObservationSearchRequest body) throws ApiException {
        Call call = searchObservationsPostCall(body);
        Type localVarReturnType = new TypeToken<ObservationListResponse>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Submit a search request for a set of Observations (asynchronously)
     * Submit a search request for a set of Observations. Returns an Id which reference the results of this search
     * @param body  (optional)

     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public Call searchObservationsPostAsync(ObservationSearchRequest body, final ApiCallback<ObservationListResponse> callback) throws ApiException {
        Call call = searchObservationsPostCall(body);
        Type localVarReturnType = new TypeToken<ObservationListResponse>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for searchObservationsSearchResultsDbIdGet
     * @param accept The requested content type which should be returned by the server (required)
     * @param searchResultsDbId Unique identifier which references the search results (required)

     * @param page Used to request a specific page of data to be returned.  The page indexing starts at 0 (the first page is &#x27;page&#x27;&#x3D; 0). Default is &#x60;0&#x60;. (optional)
     * @param pageSize The size of the pages to be returned. Default is &#x60;1000&#x60;. (optional)


     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    private Call searchObservationsSearchResultsDbIdGetCall(WSMIMEDataTypes accept, String searchResultsDbId, Integer page, Integer pageSize) throws ApiException {
        Object localVarPostBody = null;
        
        // create path and map variables
        String localVarPath = "/search/observations/{searchResultsDbId}"
            .replaceAll("\\{" + "searchResultsDbId" + "\\}", apiClient.escapeString(searchResultsDbId.toString()));

        Map<String, String> localVarQueryParams = new HashMap<>();
        Map<String, String> localVarCollectionQueryParams = new HashMap<>();
        if (page != null)
            apiClient.prepQueryParameter(localVarQueryParams, "page", page);
        if (pageSize != null)
            apiClient.prepQueryParameter(localVarQueryParams, "pageSize", pageSize);

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        if (accept != null)
        localVarHeaderParams.put("Accept", apiClient.parameterToString(accept));
        
        

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] { "AuthorizationToken" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames);
    }

    /**
     * Returns a list of Observations based on search criteria.
     * Returns a list of Observations based on search criteria.  observationTimeStamp - Iso Standard 8601.  observationValue data type inferred from the ontology
     * @param accept The requested content type which should be returned by the server (required)
     * @param searchResultsDbId Unique identifier which references the search results (required)

     * @param page Used to request a specific page of data to be returned.  The page indexing starts at 0 (the first page is &#x27;page&#x27;&#x3D; 0). Default is &#x60;0&#x60;. (optional)
     * @param pageSize The size of the pages to be returned. Default is &#x60;1000&#x60;. (optional)
     * @return ApiResponse&lt;ObservationListResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<ObservationListResponse> searchObservationsSearchResultsDbIdGet(WSMIMEDataTypes accept, String searchResultsDbId, Integer page, Integer pageSize) throws ApiException {
        Call call = searchObservationsSearchResultsDbIdGetCall(accept, searchResultsDbId, page, pageSize);
        Type localVarReturnType = new TypeToken<ObservationListResponse>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Returns a list of Observations based on search criteria. (asynchronously)
     * Returns a list of Observations based on search criteria.  observationTimeStamp - Iso Standard 8601.  observationValue data type inferred from the ontology
     * @param accept The requested content type which should be returned by the server (required)
     * @param searchResultsDbId Unique identifier which references the search results (required)

     * @param page Used to request a specific page of data to be returned.  The page indexing starts at 0 (the first page is &#x27;page&#x27;&#x3D; 0). Default is &#x60;0&#x60;. (optional)
     * @param pageSize The size of the pages to be returned. Default is &#x60;1000&#x60;. (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public Call searchObservationsSearchResultsDbIdGetAsync(WSMIMEDataTypes accept, String searchResultsDbId, Integer page, Integer pageSize, final ApiCallback<ObservationListResponse> callback) throws ApiException {
        Call call = searchObservationsSearchResultsDbIdGetCall(accept, searchResultsDbId, page, pageSize);
        Type localVarReturnType = new TypeToken<ObservationListResponse>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
}
