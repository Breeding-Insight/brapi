/*
 * BrAPI-Phenotyping
 * The Breeding API (BrAPI) is a Standardized REST ful Web Service API Specification for communicating Plant Breeding Data. BrAPI allows for easy data sharing between databases and tools involved in plant breeding. <div class=\"brapi-section\"> <h2 class=\"brapi-section-title\">General Reference Documentation</h2> <div class=\"gen-info-link\"><a href=\"https://github.com/plantbreeding/API/blob/master/Specification/GeneralInfo/URL_Structure.md\">URL Structure</a></div> <div class=\"gen-info-link\"><a href=\"https://github.com/plantbreeding/API/blob/master/Specification/GeneralInfo/Response_Structure.md\">Response Structure</a></div> <div class=\"gen-info-link\"><a href=\"https://github.com/plantbreeding/API/blob/master/Specification/GeneralInfo/Date_Time_Encoding.md\">Date/Time Encoding</a></div> <div class=\"gen-info-link\"><a href=\"https://github.com/plantbreeding/API/blob/master/Specification/GeneralInfo/Location_Encoding.md\">Location Encoding</a></div> <div class=\"gen-info-link\"><a href=\"https://github.com/plantbreeding/API/blob/master/Specification/GeneralInfo/Error_Handling.md\">Error Handling</a></div> <div class=\"gen-info-link\"><a href=\"https://github.com/plantbreeding/API/blob/master/Specification/GeneralInfo/Search_Services.md\">Search Services</a></div> </div>  <div class=\"brapi-section\"> <h2 class=\"brapi-section-title\">BrAPI Core</h2> <div class=\"brapi-section-description\">The BrAPI Core module contains high level entities used for organization and management. This includes Programs, Trials, Studies, Locations, People, and Lists</div> <div class=\"version-number\">V2.0</div> <div class=\"link-btn\"><a href=\"https://github.com/plantbreeding/API/tree/master/Specification/BrAPI-Core\">GitHub</a></div> <div class=\"link-btn\"><a href=\"https://app.swaggerhub.com/apis/PlantBreedingAPI/BrAPI-Core\">SwaggerHub</a></div> <div class=\"link-btn\"><a href=\"https://brapicore.docs.apiary.io\">Apiary</a></div> <div class=\"stop-float\"></div> </div>  <div class=\"current-brapi-section brapi-section\"> <h2 class=\"brapi-section-title\">BrAPI Phenotyping</h2> <div class=\"brapi-section-description\">The BrAPI Phenotyping module contains entities related to phenotypic observations. This includes Observation Units, Observations, Observation Variables, Traits, Scales, Methods, and Images</div> <div class=\"version-number\">V2.0</div> <div class=\"link-btn\"><a href=\"https://github.com/plantbreeding/API/tree/master/Specification/BrAPI-Phenotyping\">GitHub</a></div> <div class=\"link-btn\"><a href=\"https://app.swaggerhub.com/apis/PlantBreedingAPI/BrAPI-Phenotyping\">SwaggerHub</a></div> <div class=\"link-btn\"><a href=\"https://brapiphenotyping.docs.apiary.io\">Apiary</a></div> <div class=\"stop-float\"></div> </div>  <div class=\"brapi-section\"> <h2 class=\"brapi-section-title\">BrAPI Genotyping</h2> <div class=\"brapi-section-description\">The BrAPI Genotyping module contains entities related to genotyping analysis. This includes Samples, Markers, Variant Sets, Variants, Call Sets, Calls, References, Reads, and Vendor Orders</div> <div class=\"version-number\">V2.0</div> <div class=\"link-btn\"><a href=\"https://github.com/plantbreeding/API/tree/master/Specification/BrAPI-Genotyping\">GitHub</a></div> <div class=\"link-btn\"><a href=\"https://app.swaggerhub.com/apis/PlantBreedingAPI/BrAPI-Genotyping\">SwaggerHub</a></div> <div class=\"link-btn\"><a href=\"https://brapigenotyping.docs.apiary.io\">Apiary</a></div> <div class=\"stop-float\"></div> </div>  <div class=\"brapi-section\"> <h2 class=\"brapi-section-title\">BrAPI Germplasm</h2> <div class=\"brapi-section-description\">The BrAPI Germplasm module contains entities related to germplasm management. This includes Germplasm, Germplasm Attributes, Seed Lots, Crosses, Pedigree, and Progeny</div> <div class=\"version-number\">V2.0</div> <div class=\"link-btn\"><a href=\"https://github.com/plantbreeding/API/tree/master/Specification/BrAPI-Germplasm\">GitHub</a></div> <div class=\"link-btn\"><a href=\"https://app.swaggerhub.com/apis/PlantBreedingAPI/BrAPI-Germplasm\">SwaggerHub</a></div> <div class=\"link-btn\"><a href=\"https://brapigermplasm.docs.apiary.io\">Apiary</a></div> <div class=\"stop-float\"></div> </div>  <style> .link-btn{ float: left;  margin: 2px 10px 0 0;  padding: 0 5px;  border-radius: 5px;  background-color: #ddd; } .stop-float{   clear: both; } .version-number{   float: left;    margin: 5px 10px 0 5px; } .brapi-section-title{   margin: 0 10px 0 0;   font-size: 20px; } .current-brapi-section{   font-weight: bolder;   border-radius: 5px;    background-color: #ddd; } .brapi-section{   padding: 5px 5px;  } .brapi-section-description{   margin: 5px 0 0 5px; } </style>
 *
 * OpenAPI spec version: 2.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package io.swagger.client.org.brapi.client.api.phenotype;

import io.swagger.client.org.brapi.client.ApiCallback;
import io.swagger.client.org.brapi.client.ApiClient;
import io.swagger.client.org.brapi.client.ApiException;
import io.swagger.client.org.brapi.client.ApiResponse;
import io.swagger.client.org.brapi.client.Configuration;
import io.swagger.client.org.brapi.client.Pair;
import io.swagger.client.org.brapi.client.ProgressRequestBody;
import io.swagger.client.org.brapi.client.ProgressResponseBody;

import okhttp3.Call;
import okhttp3.Interceptor;
import okhttp3.Response;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;

import io.swagger.client.model.WSMIMEDataTypes;
import io.swagger.client.model.pheno.ObservationListResponse;
import io.swagger.client.model.pheno.ObservationNewRequest;
import io.swagger.client.model.pheno.ObservationSearchRequest;
import io.swagger.client.model.pheno.ObservationSingleResponse;
import io.swagger.client.model.pheno.ObservationTableResponse;
import java.time.OffsetDateTime;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class ObservationsApi {
    private ApiClient apiClient;

    public ObservationsApi() {
        this(Configuration.getDefaultApiClient());
    }

    public ObservationsApi(ApiClient apiClient) {
        this.apiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return apiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.apiClient = apiClient;
    }

    /**
     * Build call for observationsGet
     * @param observationDbId The unique ID of an Observation (optional)
     * @param observationUnitDbId The unique ID of an Observation Unit (optional)
     * @param germplasmDbId The unique ID of a germplasm (accession) to filter on (optional)
     * @param observationVariableDbId The unique ID of an observation variable (optional)
     * @param studyDbId The unique ID of a studies to filter on (optional)
     * @param locationDbId The unique ID of a location where these observations were collected (optional)
     * @param trialDbId The unique ID of a trial to filter on (optional)
     * @param programDbId The unique ID of a program to filter on (optional)
     * @param seasonDbId The year or Phenotyping campaign of a multi-annual study (trees, grape, ...) (optional)
     * @param observationUnitLevelName The Observation Unit Level. Returns only the observation unit of the specified Level. References ObservationUnit-&gt;observationUnitPosition-&gt;observationLevel-&gt;levelName (optional)
     * @param observationUnitLevelOrder The Observation Unit Level Order Number. Returns only the observation unit of the specified Level. References ObservationUnit-&gt;observationUnitPosition-&gt;observationLevel-&gt;levelOrder (optional)
     * @param observationUnitLevelCode The Observation Unit Level Code. This parameter should be used together with &#x60;observationUnitLevelName&#x60; or &#x60;observationUnitLevelOrder&#x60;. References ObservationUnit-&gt;observationUnitPosition-&gt;observationLevel-&gt;levelCode (optional)
     * @param observationTimeStampRangeStart Timestamp range start (optional)
     * @param observationTimeStampRangeEnd Timestamp range end (optional)
     * @param externalReferenceID An external reference ID. Could be a simple string or a URI. (use with &#x60;externalReferenceSource&#x60; parameter) (optional)
     * @param externalReferenceSource An identifier for the source system or database of an external reference (use with &#x60;externalReferenceID&#x60; parameter) (optional)
     * @param page Used to request a specific page of data to be returned.  The page indexing starts at 0 (the first page is &#x27;page&#x27;&#x3D; 0). Default is &#x60;0&#x60;. (optional)
     * @param pageSize The size of the pages to be returned. Default is &#x60;1000&#x60;. (optional)
     * @param authorization HTTP HEADER - Token used for Authorization   &lt;strong&gt; Bearer {token_string} &lt;/strong&gt; (optional)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public Call observationsGetCall(String observationDbId, String observationUnitDbId, String germplasmDbId, String observationVariableDbId, String studyDbId, String locationDbId, String trialDbId, String programDbId, String seasonDbId, String observationUnitLevelName, String observationUnitLevelOrder, String observationUnitLevelCode, OffsetDateTime observationTimeStampRangeStart, OffsetDateTime observationTimeStampRangeEnd, String externalReferenceID, String externalReferenceSource, Integer page, Integer pageSize, String authorization, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // create path and map variables
        String localVarPath = "/observations";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        if (observationDbId != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("observationDbId", observationDbId));
        if (observationUnitDbId != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("observationUnitDbId", observationUnitDbId));
        if (germplasmDbId != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("germplasmDbId", germplasmDbId));
        if (observationVariableDbId != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("observationVariableDbId", observationVariableDbId));
        if (studyDbId != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("studyDbId", studyDbId));
        if (locationDbId != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("locationDbId", locationDbId));
        if (trialDbId != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("trialDbId", trialDbId));
        if (programDbId != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("programDbId", programDbId));
        if (seasonDbId != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("seasonDbId", seasonDbId));
        if (observationUnitLevelName != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("observationUnitLevelName", observationUnitLevelName));
        if (observationUnitLevelOrder != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("observationUnitLevelOrder", observationUnitLevelOrder));
        if (observationUnitLevelCode != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("observationUnitLevelCode", observationUnitLevelCode));
        if (observationTimeStampRangeStart != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("observationTimeStampRangeStart", observationTimeStampRangeStart));
        if (observationTimeStampRangeEnd != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("observationTimeStampRangeEnd", observationTimeStampRangeEnd));
        if (externalReferenceID != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("externalReferenceID", externalReferenceID));
        if (externalReferenceSource != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("externalReferenceSource", externalReferenceSource));
        if (page != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("page", page));
        if (pageSize != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("pageSize", pageSize));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        if (authorization != null)
        localVarHeaderParams.put("Authorization", apiClient.parameterToString(authorization));

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new Interceptor() {
                @Override
                public Response intercept(Interceptor.Chain chain) throws IOException {
                    Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "AuthorizationToken" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }
    
    @SuppressWarnings("rawtypes")
    private Call observationsGetValidateBeforeCall(String observationDbId, String observationUnitDbId, String germplasmDbId, String observationVariableDbId, String studyDbId, String locationDbId, String trialDbId, String programDbId, String seasonDbId, String observationUnitLevelName, String observationUnitLevelOrder, String observationUnitLevelCode, OffsetDateTime observationTimeStampRangeStart, OffsetDateTime observationTimeStampRangeEnd, String externalReferenceID, String externalReferenceSource, Integer page, Integer pageSize, String authorization, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        Call call = observationsGetCall(observationDbId, observationUnitDbId, germplasmDbId, observationVariableDbId, studyDbId, locationDbId, trialDbId, programDbId, seasonDbId, observationUnitLevelName, observationUnitLevelOrder, observationUnitLevelCode, observationTimeStampRangeStart, observationTimeStampRangeEnd, externalReferenceID, externalReferenceSource, page, pageSize, authorization, progressListener, progressRequestListener);
        return call;

        
        
        
        
    }

    /**
     * Get a filtered set of Observations
     * Retrieve all observations where there are measurements for the given observation variables.  observationTimestamp should be ISO8601 format with timezone -&gt; YYYY-MM-DDThh:mm:ss+hhmm
     * @param observationDbId The unique ID of an Observation (optional)
     * @param observationUnitDbId The unique ID of an Observation Unit (optional)
     * @param germplasmDbId The unique ID of a germplasm (accession) to filter on (optional)
     * @param observationVariableDbId The unique ID of an observation variable (optional)
     * @param studyDbId The unique ID of a studies to filter on (optional)
     * @param locationDbId The unique ID of a location where these observations were collected (optional)
     * @param trialDbId The unique ID of a trial to filter on (optional)
     * @param programDbId The unique ID of a program to filter on (optional)
     * @param seasonDbId The year or Phenotyping campaign of a multi-annual study (trees, grape, ...) (optional)
     * @param observationUnitLevelName The Observation Unit Level. Returns only the observation unit of the specified Level. References ObservationUnit-&gt;observationUnitPosition-&gt;observationLevel-&gt;levelName (optional)
     * @param observationUnitLevelOrder The Observation Unit Level Order Number. Returns only the observation unit of the specified Level. References ObservationUnit-&gt;observationUnitPosition-&gt;observationLevel-&gt;levelOrder (optional)
     * @param observationUnitLevelCode The Observation Unit Level Code. This parameter should be used together with &#x60;observationUnitLevelName&#x60; or &#x60;observationUnitLevelOrder&#x60;. References ObservationUnit-&gt;observationUnitPosition-&gt;observationLevel-&gt;levelCode (optional)
     * @param observationTimeStampRangeStart Timestamp range start (optional)
     * @param observationTimeStampRangeEnd Timestamp range end (optional)
     * @param externalReferenceID An external reference ID. Could be a simple string or a URI. (use with &#x60;externalReferenceSource&#x60; parameter) (optional)
     * @param externalReferenceSource An identifier for the source system or database of an external reference (use with &#x60;externalReferenceID&#x60; parameter) (optional)
     * @param page Used to request a specific page of data to be returned.  The page indexing starts at 0 (the first page is &#x27;page&#x27;&#x3D; 0). Default is &#x60;0&#x60;. (optional)
     * @param pageSize The size of the pages to be returned. Default is &#x60;1000&#x60;. (optional)
     * @param authorization HTTP HEADER - Token used for Authorization   &lt;strong&gt; Bearer {token_string} &lt;/strong&gt; (optional)
     * @return ObservationListResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ObservationListResponse observationsGet(String observationDbId, String observationUnitDbId, String germplasmDbId, String observationVariableDbId, String studyDbId, String locationDbId, String trialDbId, String programDbId, String seasonDbId, String observationUnitLevelName, String observationUnitLevelOrder, String observationUnitLevelCode, OffsetDateTime observationTimeStampRangeStart, OffsetDateTime observationTimeStampRangeEnd, String externalReferenceID, String externalReferenceSource, Integer page, Integer pageSize, String authorization) throws ApiException {
        ApiResponse<ObservationListResponse> resp = observationsGetWithHttpInfo(observationDbId, observationUnitDbId, germplasmDbId, observationVariableDbId, studyDbId, locationDbId, trialDbId, programDbId, seasonDbId, observationUnitLevelName, observationUnitLevelOrder, observationUnitLevelCode, observationTimeStampRangeStart, observationTimeStampRangeEnd, externalReferenceID, externalReferenceSource, page, pageSize, authorization);
        return resp.getData();
    }

    /**
     * Get a filtered set of Observations
     * Retrieve all observations where there are measurements for the given observation variables.  observationTimestamp should be ISO8601 format with timezone -&gt; YYYY-MM-DDThh:mm:ss+hhmm
     * @param observationDbId The unique ID of an Observation (optional)
     * @param observationUnitDbId The unique ID of an Observation Unit (optional)
     * @param germplasmDbId The unique ID of a germplasm (accession) to filter on (optional)
     * @param observationVariableDbId The unique ID of an observation variable (optional)
     * @param studyDbId The unique ID of a studies to filter on (optional)
     * @param locationDbId The unique ID of a location where these observations were collected (optional)
     * @param trialDbId The unique ID of a trial to filter on (optional)
     * @param programDbId The unique ID of a program to filter on (optional)
     * @param seasonDbId The year or Phenotyping campaign of a multi-annual study (trees, grape, ...) (optional)
     * @param observationUnitLevelName The Observation Unit Level. Returns only the observation unit of the specified Level. References ObservationUnit-&gt;observationUnitPosition-&gt;observationLevel-&gt;levelName (optional)
     * @param observationUnitLevelOrder The Observation Unit Level Order Number. Returns only the observation unit of the specified Level. References ObservationUnit-&gt;observationUnitPosition-&gt;observationLevel-&gt;levelOrder (optional)
     * @param observationUnitLevelCode The Observation Unit Level Code. This parameter should be used together with &#x60;observationUnitLevelName&#x60; or &#x60;observationUnitLevelOrder&#x60;. References ObservationUnit-&gt;observationUnitPosition-&gt;observationLevel-&gt;levelCode (optional)
     * @param observationTimeStampRangeStart Timestamp range start (optional)
     * @param observationTimeStampRangeEnd Timestamp range end (optional)
     * @param externalReferenceID An external reference ID. Could be a simple string or a URI. (use with &#x60;externalReferenceSource&#x60; parameter) (optional)
     * @param externalReferenceSource An identifier for the source system or database of an external reference (use with &#x60;externalReferenceID&#x60; parameter) (optional)
     * @param page Used to request a specific page of data to be returned.  The page indexing starts at 0 (the first page is &#x27;page&#x27;&#x3D; 0). Default is &#x60;0&#x60;. (optional)
     * @param pageSize The size of the pages to be returned. Default is &#x60;1000&#x60;. (optional)
     * @param authorization HTTP HEADER - Token used for Authorization   &lt;strong&gt; Bearer {token_string} &lt;/strong&gt; (optional)
     * @return ApiResponse&lt;ObservationListResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<ObservationListResponse> observationsGetWithHttpInfo(String observationDbId, String observationUnitDbId, String germplasmDbId, String observationVariableDbId, String studyDbId, String locationDbId, String trialDbId, String programDbId, String seasonDbId, String observationUnitLevelName, String observationUnitLevelOrder, String observationUnitLevelCode, OffsetDateTime observationTimeStampRangeStart, OffsetDateTime observationTimeStampRangeEnd, String externalReferenceID, String externalReferenceSource, Integer page, Integer pageSize, String authorization) throws ApiException {
        Call call = observationsGetValidateBeforeCall(observationDbId, observationUnitDbId, germplasmDbId, observationVariableDbId, studyDbId, locationDbId, trialDbId, programDbId, seasonDbId, observationUnitLevelName, observationUnitLevelOrder, observationUnitLevelCode, observationTimeStampRangeStart, observationTimeStampRangeEnd, externalReferenceID, externalReferenceSource, page, pageSize, authorization, null, null);
        Type localVarReturnType = new TypeToken<ObservationListResponse>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Get a filtered set of Observations (asynchronously)
     * Retrieve all observations where there are measurements for the given observation variables.  observationTimestamp should be ISO8601 format with timezone -&gt; YYYY-MM-DDThh:mm:ss+hhmm
     * @param observationDbId The unique ID of an Observation (optional)
     * @param observationUnitDbId The unique ID of an Observation Unit (optional)
     * @param germplasmDbId The unique ID of a germplasm (accession) to filter on (optional)
     * @param observationVariableDbId The unique ID of an observation variable (optional)
     * @param studyDbId The unique ID of a studies to filter on (optional)
     * @param locationDbId The unique ID of a location where these observations were collected (optional)
     * @param trialDbId The unique ID of a trial to filter on (optional)
     * @param programDbId The unique ID of a program to filter on (optional)
     * @param seasonDbId The year or Phenotyping campaign of a multi-annual study (trees, grape, ...) (optional)
     * @param observationUnitLevelName The Observation Unit Level. Returns only the observation unit of the specified Level. References ObservationUnit-&gt;observationUnitPosition-&gt;observationLevel-&gt;levelName (optional)
     * @param observationUnitLevelOrder The Observation Unit Level Order Number. Returns only the observation unit of the specified Level. References ObservationUnit-&gt;observationUnitPosition-&gt;observationLevel-&gt;levelOrder (optional)
     * @param observationUnitLevelCode The Observation Unit Level Code. This parameter should be used together with &#x60;observationUnitLevelName&#x60; or &#x60;observationUnitLevelOrder&#x60;. References ObservationUnit-&gt;observationUnitPosition-&gt;observationLevel-&gt;levelCode (optional)
     * @param observationTimeStampRangeStart Timestamp range start (optional)
     * @param observationTimeStampRangeEnd Timestamp range end (optional)
     * @param externalReferenceID An external reference ID. Could be a simple string or a URI. (use with &#x60;externalReferenceSource&#x60; parameter) (optional)
     * @param externalReferenceSource An identifier for the source system or database of an external reference (use with &#x60;externalReferenceID&#x60; parameter) (optional)
     * @param page Used to request a specific page of data to be returned.  The page indexing starts at 0 (the first page is &#x27;page&#x27;&#x3D; 0). Default is &#x60;0&#x60;. (optional)
     * @param pageSize The size of the pages to be returned. Default is &#x60;1000&#x60;. (optional)
     * @param authorization HTTP HEADER - Token used for Authorization   &lt;strong&gt; Bearer {token_string} &lt;/strong&gt; (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public Call observationsGetAsync(String observationDbId, String observationUnitDbId, String germplasmDbId, String observationVariableDbId, String studyDbId, String locationDbId, String trialDbId, String programDbId, String seasonDbId, String observationUnitLevelName, String observationUnitLevelOrder, String observationUnitLevelCode, OffsetDateTime observationTimeStampRangeStart, OffsetDateTime observationTimeStampRangeEnd, String externalReferenceID, String externalReferenceSource, Integer page, Integer pageSize, String authorization, final ApiCallback<ObservationListResponse> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        Call call = observationsGetValidateBeforeCall(observationDbId, observationUnitDbId, germplasmDbId, observationVariableDbId, studyDbId, locationDbId, trialDbId, programDbId, seasonDbId, observationUnitLevelName, observationUnitLevelOrder, observationUnitLevelCode, observationTimeStampRangeStart, observationTimeStampRangeEnd, externalReferenceID, externalReferenceSource, page, pageSize, authorization, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<ObservationListResponse>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for observationsObservationDbIdGet
     * @param observationDbId The unique ID of an observation (required)
     * @param authorization HTTP HEADER - Token used for Authorization   &lt;strong&gt; Bearer {token_string} &lt;/strong&gt; (optional)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public Call observationsObservationDbIdGetCall(String observationDbId, String authorization, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // create path and map variables
        String localVarPath = "/observations/{observationDbId}"
            .replaceAll("\\{" + "observationDbId" + "\\}", apiClient.escapeString(observationDbId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        if (authorization != null)
        localVarHeaderParams.put("Authorization", apiClient.parameterToString(authorization));

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new Interceptor() {
                @Override
                public Response intercept(Interceptor.Chain chain) throws IOException {
                    Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "AuthorizationToken" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }
    
    @SuppressWarnings("rawtypes")
    private Call observationsObservationDbIdGetValidateBeforeCall(String observationDbId, String authorization, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        // verify the required parameter 'observationDbId' is set
        if (observationDbId == null) {
            throw new ApiException("Missing the required parameter 'observationDbId' when calling observationsObservationDbIdGet(Async)");
        }
        
        Call call = observationsObservationDbIdGetCall(observationDbId, authorization, progressListener, progressRequestListener);
        return call;

        
        
        
        
    }

    /**
     * Get the details of a specific Observations
     * Get the details of a specific Observations  observationTimestamp should be ISO8601 format with timezone -&gt; YYYY-MM-DDThh:mm:ss+hhmm
     * @param observationDbId The unique ID of an observation (required)
     * @param authorization HTTP HEADER - Token used for Authorization   &lt;strong&gt; Bearer {token_string} &lt;/strong&gt; (optional)
     * @return ObservationSingleResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ObservationSingleResponse observationsObservationDbIdGet(String observationDbId, String authorization) throws ApiException {
        ApiResponse<ObservationSingleResponse> resp = observationsObservationDbIdGetWithHttpInfo(observationDbId, authorization);
        return resp.getData();
    }

    /**
     * Get the details of a specific Observations
     * Get the details of a specific Observations  observationTimestamp should be ISO8601 format with timezone -&gt; YYYY-MM-DDThh:mm:ss+hhmm
     * @param observationDbId The unique ID of an observation (required)
     * @param authorization HTTP HEADER - Token used for Authorization   &lt;strong&gt; Bearer {token_string} &lt;/strong&gt; (optional)
     * @return ApiResponse&lt;ObservationSingleResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<ObservationSingleResponse> observationsObservationDbIdGetWithHttpInfo(String observationDbId, String authorization) throws ApiException {
        Call call = observationsObservationDbIdGetValidateBeforeCall(observationDbId, authorization, null, null);
        Type localVarReturnType = new TypeToken<ObservationSingleResponse>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Get the details of a specific Observations (asynchronously)
     * Get the details of a specific Observations  observationTimestamp should be ISO8601 format with timezone -&gt; YYYY-MM-DDThh:mm:ss+hhmm
     * @param observationDbId The unique ID of an observation (required)
     * @param authorization HTTP HEADER - Token used for Authorization   &lt;strong&gt; Bearer {token_string} &lt;/strong&gt; (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public Call observationsObservationDbIdGetAsync(String observationDbId, String authorization, final ApiCallback<ObservationSingleResponse> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        Call call = observationsObservationDbIdGetValidateBeforeCall(observationDbId, authorization, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<ObservationSingleResponse>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for observationsObservationDbIdPut
     * @param observationDbId The unique ID of an observation (required)
     * @param body  (optional)
     * @param authorization HTTP HEADER - Token used for Authorization   &lt;strong&gt; Bearer {token_string} &lt;/strong&gt; (optional)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public Call observationsObservationDbIdPutCall(String observationDbId, ObservationNewRequest body, String authorization, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = body;
        
        // create path and map variables
        String localVarPath = "/observations/{observationDbId}"
            .replaceAll("\\{" + "observationDbId" + "\\}", apiClient.escapeString(observationDbId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        if (authorization != null)
        localVarHeaderParams.put("Authorization", apiClient.parameterToString(authorization));

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new Interceptor() {
                @Override
                public Response intercept(Interceptor.Chain chain) throws IOException {
                    Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "AuthorizationToken" };
        return apiClient.buildCall(localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }
    
    @SuppressWarnings("rawtypes")
    private Call observationsObservationDbIdPutValidateBeforeCall(String observationDbId, ObservationNewRequest body, String authorization, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        // verify the required parameter 'observationDbId' is set
        if (observationDbId == null) {
            throw new ApiException("Missing the required parameter 'observationDbId' when calling observationsObservationDbIdPut(Async)");
        }
        
        Call call = observationsObservationDbIdPutCall(observationDbId, body, authorization, progressListener, progressRequestListener);
        return call;

        
        
        
        
    }

    /**
     * Update an existing Observation
     * Update an existing Observation
     * @param observationDbId The unique ID of an observation (required)
     * @param body  (optional)
     * @param authorization HTTP HEADER - Token used for Authorization   &lt;strong&gt; Bearer {token_string} &lt;/strong&gt; (optional)
     * @return ObservationSingleResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ObservationSingleResponse observationsObservationDbIdPut(String observationDbId, ObservationNewRequest body, String authorization) throws ApiException {
        ApiResponse<ObservationSingleResponse> resp = observationsObservationDbIdPutWithHttpInfo(observationDbId, body, authorization);
        return resp.getData();
    }

    /**
     * Update an existing Observation
     * Update an existing Observation
     * @param observationDbId The unique ID of an observation (required)
     * @param body  (optional)
     * @param authorization HTTP HEADER - Token used for Authorization   &lt;strong&gt; Bearer {token_string} &lt;/strong&gt; (optional)
     * @return ApiResponse&lt;ObservationSingleResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<ObservationSingleResponse> observationsObservationDbIdPutWithHttpInfo(String observationDbId, ObservationNewRequest body, String authorization) throws ApiException {
        Call call = observationsObservationDbIdPutValidateBeforeCall(observationDbId, body, authorization, null, null);
        Type localVarReturnType = new TypeToken<ObservationSingleResponse>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Update an existing Observation (asynchronously)
     * Update an existing Observation
     * @param observationDbId The unique ID of an observation (required)
     * @param body  (optional)
     * @param authorization HTTP HEADER - Token used for Authorization   &lt;strong&gt; Bearer {token_string} &lt;/strong&gt; (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public Call observationsObservationDbIdPutAsync(String observationDbId, ObservationNewRequest body, String authorization, final ApiCallback<ObservationSingleResponse> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        Call call = observationsObservationDbIdPutValidateBeforeCall(observationDbId, body, authorization, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<ObservationSingleResponse>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for observationsPost
     * @param body  (optional)
     * @param authorization HTTP HEADER - Token used for Authorization   &lt;strong&gt; Bearer {token_string} &lt;/strong&gt; (optional)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public Call observationsPostCall(List<ObservationNewRequest> body, String authorization, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = body;
        
        // create path and map variables
        String localVarPath = "/observations";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        if (authorization != null)
        localVarHeaderParams.put("Authorization", apiClient.parameterToString(authorization));

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new Interceptor() {
                @Override
                public Response intercept(Interceptor.Chain chain) throws IOException {
                    Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "AuthorizationToken" };
        return apiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }
    
    @SuppressWarnings("rawtypes")
    private Call observationsPostValidateBeforeCall(List<ObservationNewRequest> body, String authorization, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        Call call = observationsPostCall(body, authorization, progressListener, progressRequestListener);
        return call;

        
        
        
        
    }

    /**
     * Add new Observation entities
     * Add new Observation entities
     * @param body  (optional)
     * @param authorization HTTP HEADER - Token used for Authorization   &lt;strong&gt; Bearer {token_string} &lt;/strong&gt; (optional)
     * @return ObservationListResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ObservationListResponse observationsPost(List<ObservationNewRequest> body, String authorization) throws ApiException {
        ApiResponse<ObservationListResponse> resp = observationsPostWithHttpInfo(body, authorization);
        return resp.getData();
    }

    /**
     * Add new Observation entities
     * Add new Observation entities
     * @param body  (optional)
     * @param authorization HTTP HEADER - Token used for Authorization   &lt;strong&gt; Bearer {token_string} &lt;/strong&gt; (optional)
     * @return ApiResponse&lt;ObservationListResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<ObservationListResponse> observationsPostWithHttpInfo(List<ObservationNewRequest> body, String authorization) throws ApiException {
        Call call = observationsPostValidateBeforeCall(body, authorization, null, null);
        Type localVarReturnType = new TypeToken<ObservationListResponse>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Add new Observation entities (asynchronously)
     * Add new Observation entities
     * @param body  (optional)
     * @param authorization HTTP HEADER - Token used for Authorization   &lt;strong&gt; Bearer {token_string} &lt;/strong&gt; (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public Call observationsPostAsync(List<ObservationNewRequest> body, String authorization, final ApiCallback<ObservationListResponse> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        Call call = observationsPostValidateBeforeCall(body, authorization, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<ObservationListResponse>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for observationsPut
     * @param body  (optional)
     * @param authorization HTTP HEADER - Token used for Authorization   &lt;strong&gt; Bearer {token_string} &lt;/strong&gt; (optional)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public Call observationsPutCall(Map<String, ObservationNewRequest> body, String authorization, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = body;
        
        // create path and map variables
        String localVarPath = "/observations";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        if (authorization != null)
        localVarHeaderParams.put("Authorization", apiClient.parameterToString(authorization));

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new Interceptor() {
                @Override
                public Response intercept(Interceptor.Chain chain) throws IOException {
                    Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "AuthorizationToken" };
        return apiClient.buildCall(localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }
    
    @SuppressWarnings("rawtypes")
    private Call observationsPutValidateBeforeCall(Map<String, ObservationNewRequest> body, String authorization, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        Call call = observationsPutCall(body, authorization, progressListener, progressRequestListener);
        return call;

        
        
        
        
    }

    /**
     * Update multiple Observation entities
     * Update multiple Observation entities simultaneously with a single call  Include as many &#x60;observationDbIds&#x60; in the request as needed.  Note - In strictly typed languages, this structure can be represented as a Map or Dictionary of objects and parsed directly from JSON.
     * @param body  (optional)
     * @param authorization HTTP HEADER - Token used for Authorization   &lt;strong&gt; Bearer {token_string} &lt;/strong&gt; (optional)
     * @return ObservationListResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ObservationListResponse observationsPut(Map<String, ObservationNewRequest> body, String authorization) throws ApiException {
        ApiResponse<ObservationListResponse> resp = observationsPutWithHttpInfo(body, authorization);
        return resp.getData();
    }

    /**
     * Update multiple Observation entities
     * Update multiple Observation entities simultaneously with a single call  Include as many &#x60;observationDbIds&#x60; in the request as needed.  Note - In strictly typed languages, this structure can be represented as a Map or Dictionary of objects and parsed directly from JSON.
     * @param body  (optional)
     * @param authorization HTTP HEADER - Token used for Authorization   &lt;strong&gt; Bearer {token_string} &lt;/strong&gt; (optional)
     * @return ApiResponse&lt;ObservationListResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<ObservationListResponse> observationsPutWithHttpInfo(Map<String, ObservationNewRequest> body, String authorization) throws ApiException {
        Call call = observationsPutValidateBeforeCall(body, authorization, null, null);
        Type localVarReturnType = new TypeToken<ObservationListResponse>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Update multiple Observation entities (asynchronously)
     * Update multiple Observation entities simultaneously with a single call  Include as many &#x60;observationDbIds&#x60; in the request as needed.  Note - In strictly typed languages, this structure can be represented as a Map or Dictionary of objects and parsed directly from JSON.
     * @param body  (optional)
     * @param authorization HTTP HEADER - Token used for Authorization   &lt;strong&gt; Bearer {token_string} &lt;/strong&gt; (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public Call observationsPutAsync(Map<String, ObservationNewRequest> body, String authorization, final ApiCallback<ObservationListResponse> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        Call call = observationsPutValidateBeforeCall(body, authorization, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<ObservationListResponse>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for observationsTableGet
     * @param accept The requested content type which should be returned by the server (required)
     * @param observationUnitDbId The unique ID of an Observation Unit (optional)
     * @param germplasmDbId The unique ID of a germplasm (accession) to filter on (optional)
     * @param observationVariableDbId The unique ID of an observation variable (optional)
     * @param studyDbId The unique ID of a studies to filter on (optional)
     * @param locationDbId The unique ID of a location where these observations were collected (optional)
     * @param trialDbId The unique ID of a trial to filter on (optional)
     * @param programDbId The unique ID of a program to filter on (optional)
     * @param seasonDbId The year or Phenotyping campaign of a multi-annual study (trees, grape, ...) (optional)
     * @param observationLevel The type of the observationUnit. Returns only the observation unit of the specified type; the parent levels ID can be accessed through observationUnitStructure. (optional)
     * @param searchResultsDbId Permanent unique identifier which references the search results (optional)
     * @param observationTimeStampRangeStart Timestamp range start (optional)
     * @param observationTimeStampRangeEnd Timestamp range end (optional)
     * @param authorization HTTP HEADER - Token used for Authorization   &lt;strong&gt; Bearer {token_string} &lt;/strong&gt; (optional)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public Call observationsTableGetCall(WSMIMEDataTypes accept, String observationUnitDbId, String germplasmDbId, String observationVariableDbId, String studyDbId, String locationDbId, String trialDbId, String programDbId, String seasonDbId, String observationLevel, String searchResultsDbId, OffsetDateTime observationTimeStampRangeStart, OffsetDateTime observationTimeStampRangeEnd, String authorization, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // create path and map variables
        String localVarPath = "/observations/table";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        if (observationUnitDbId != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("observationUnitDbId", observationUnitDbId));
        if (germplasmDbId != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("germplasmDbId", germplasmDbId));
        if (observationVariableDbId != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("observationVariableDbId", observationVariableDbId));
        if (studyDbId != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("studyDbId", studyDbId));
        if (locationDbId != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("locationDbId", locationDbId));
        if (trialDbId != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("trialDbId", trialDbId));
        if (programDbId != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("programDbId", programDbId));
        if (seasonDbId != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("seasonDbId", seasonDbId));
        if (observationLevel != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("observationLevel", observationLevel));
        if (searchResultsDbId != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("searchResultsDbId", searchResultsDbId));
        if (observationTimeStampRangeStart != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("observationTimeStampRangeStart", observationTimeStampRangeStart));
        if (observationTimeStampRangeEnd != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("observationTimeStampRangeEnd", observationTimeStampRangeEnd));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        if (accept != null)
        localVarHeaderParams.put("Accept", apiClient.parameterToString(accept));
        if (authorization != null)
        localVarHeaderParams.put("Authorization", apiClient.parameterToString(authorization));

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json", "text/csv", "text/tsv"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new Interceptor() {
                @Override
                public Response intercept(Interceptor.Chain chain) throws IOException {
                    Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "AuthorizationToken" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }
    
    @SuppressWarnings("rawtypes")
    private Call observationsTableGetValidateBeforeCall(WSMIMEDataTypes accept, String observationUnitDbId, String germplasmDbId, String observationVariableDbId, String studyDbId, String locationDbId, String trialDbId, String programDbId, String seasonDbId, String observationLevel, String searchResultsDbId, OffsetDateTime observationTimeStampRangeStart, OffsetDateTime observationTimeStampRangeEnd, String authorization, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        // verify the required parameter 'accept' is set
        if (accept == null) {
            throw new ApiException("Missing the required parameter 'accept' when calling observationsTableGet(Async)");
        }
        
        Call call = observationsTableGetCall(accept, observationUnitDbId, germplasmDbId, observationVariableDbId, studyDbId, locationDbId, trialDbId, programDbId, seasonDbId, observationLevel, searchResultsDbId, observationTimeStampRangeStart, observationTimeStampRangeEnd, authorization, progressListener, progressRequestListener);
        return call;

        
        
        
        
    }

    /**
     * Get a list of Observations in a table format
     * &lt;p&gt;This service is designed to retrieve a table of time dependant observation values as a matrix of Observation Units and Observation Variables. This is also sometimes called a Time Series. This service takes the \&quot;Sparse Table\&quot; approach for representing this time dependant data.&lt;/p&gt; &lt;p&gt;The table may be represented by JSON, CSV, or TSV. The \&quot;Accept\&quot; HTTP header is used for the client to request different return formats.  By default, if the \&quot;Accept\&quot; header is not included in the request, the server should return JSON as described below.&lt;/p&gt; &lt;p&gt;The table is REQUIRED to have the following columns&lt;/p&gt; &lt;ul&gt;   &lt;li&gt;observationUnitDbId - Each row is related to one Observation Unit&lt;/li&gt;   &lt;li&gt;observationTimeStamp - Each row is has a time stamp for when the observation was taken&lt;/li&gt;   &lt;li&gt;At least one column with an observationVariableDbId&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;The table may have any or all of the following OPTIONAL columns. Included columns are decided by the server developer&lt;/p&gt; &lt;ul&gt;   &lt;li&gt;observationUnitName&lt;/li&gt;   &lt;li&gt;studyDbId&lt;/li&gt;   &lt;li&gt;studyName&lt;/li&gt;   &lt;li&gt;germplasmDbId&lt;/li&gt;   &lt;li&gt;germplasmName&lt;/li&gt;   &lt;li&gt;positionCoordinateX&lt;/li&gt;   &lt;li&gt;positionCoordinateY&lt;/li&gt;   &lt;li&gt;year&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;The table also may have any number of Observation Unit Hierarchy Level columns. For example:&lt;/p&gt; &lt;ul&gt;   &lt;li&gt;field&lt;/li&gt;   &lt;li&gt;plot&lt;/li&gt;   &lt;li&gt;sub-plot&lt;/li&gt;   &lt;li&gt;plant&lt;/li&gt;   &lt;li&gt;pot&lt;/li&gt;   &lt;li&gt;block&lt;/li&gt;   &lt;li&gt;entry&lt;/li&gt;   &lt;li&gt;rep&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;The JSON representation provides a pair of extra arrays for defining the headers of the table.  The first array \&quot;headerRow\&quot; will always contain \&quot;observationUnitDbId\&quot; and any or all of the OPTIONAL column header names.  The second array \&quot;observationVariables\&quot; contains the names and DbIds for the Observation Variables represented in the table.  By appending the two arrays, you can construct the complete header row of the table. &lt;/p&gt; &lt;p&gt;For CSV and TSV representations of the table, an extra header row is needed to describe both the Observation Variable DbId and the Observation Variable Name for each data column.  See the example responses below&lt;/p&gt; 
     * @param accept The requested content type which should be returned by the server (required)
     * @param observationUnitDbId The unique ID of an Observation Unit (optional)
     * @param germplasmDbId The unique ID of a germplasm (accession) to filter on (optional)
     * @param observationVariableDbId The unique ID of an observation variable (optional)
     * @param studyDbId The unique ID of a studies to filter on (optional)
     * @param locationDbId The unique ID of a location where these observations were collected (optional)
     * @param trialDbId The unique ID of a trial to filter on (optional)
     * @param programDbId The unique ID of a program to filter on (optional)
     * @param seasonDbId The year or Phenotyping campaign of a multi-annual study (trees, grape, ...) (optional)
     * @param observationLevel The type of the observationUnit. Returns only the observation unit of the specified type; the parent levels ID can be accessed through observationUnitStructure. (optional)
     * @param searchResultsDbId Permanent unique identifier which references the search results (optional)
     * @param observationTimeStampRangeStart Timestamp range start (optional)
     * @param observationTimeStampRangeEnd Timestamp range end (optional)
     * @param authorization HTTP HEADER - Token used for Authorization   &lt;strong&gt; Bearer {token_string} &lt;/strong&gt; (optional)
     * @return ObservationTableResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ObservationTableResponse observationsTableGet(WSMIMEDataTypes accept, String observationUnitDbId, String germplasmDbId, String observationVariableDbId, String studyDbId, String locationDbId, String trialDbId, String programDbId, String seasonDbId, String observationLevel, String searchResultsDbId, OffsetDateTime observationTimeStampRangeStart, OffsetDateTime observationTimeStampRangeEnd, String authorization) throws ApiException {
        ApiResponse<ObservationTableResponse> resp = observationsTableGetWithHttpInfo(accept, observationUnitDbId, germplasmDbId, observationVariableDbId, studyDbId, locationDbId, trialDbId, programDbId, seasonDbId, observationLevel, searchResultsDbId, observationTimeStampRangeStart, observationTimeStampRangeEnd, authorization);
        return resp.getData();
    }

    /**
     * Get a list of Observations in a table format
     * &lt;p&gt;This service is designed to retrieve a table of time dependant observation values as a matrix of Observation Units and Observation Variables. This is also sometimes called a Time Series. This service takes the \&quot;Sparse Table\&quot; approach for representing this time dependant data.&lt;/p&gt; &lt;p&gt;The table may be represented by JSON, CSV, or TSV. The \&quot;Accept\&quot; HTTP header is used for the client to request different return formats.  By default, if the \&quot;Accept\&quot; header is not included in the request, the server should return JSON as described below.&lt;/p&gt; &lt;p&gt;The table is REQUIRED to have the following columns&lt;/p&gt; &lt;ul&gt;   &lt;li&gt;observationUnitDbId - Each row is related to one Observation Unit&lt;/li&gt;   &lt;li&gt;observationTimeStamp - Each row is has a time stamp for when the observation was taken&lt;/li&gt;   &lt;li&gt;At least one column with an observationVariableDbId&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;The table may have any or all of the following OPTIONAL columns. Included columns are decided by the server developer&lt;/p&gt; &lt;ul&gt;   &lt;li&gt;observationUnitName&lt;/li&gt;   &lt;li&gt;studyDbId&lt;/li&gt;   &lt;li&gt;studyName&lt;/li&gt;   &lt;li&gt;germplasmDbId&lt;/li&gt;   &lt;li&gt;germplasmName&lt;/li&gt;   &lt;li&gt;positionCoordinateX&lt;/li&gt;   &lt;li&gt;positionCoordinateY&lt;/li&gt;   &lt;li&gt;year&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;The table also may have any number of Observation Unit Hierarchy Level columns. For example:&lt;/p&gt; &lt;ul&gt;   &lt;li&gt;field&lt;/li&gt;   &lt;li&gt;plot&lt;/li&gt;   &lt;li&gt;sub-plot&lt;/li&gt;   &lt;li&gt;plant&lt;/li&gt;   &lt;li&gt;pot&lt;/li&gt;   &lt;li&gt;block&lt;/li&gt;   &lt;li&gt;entry&lt;/li&gt;   &lt;li&gt;rep&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;The JSON representation provides a pair of extra arrays for defining the headers of the table.  The first array \&quot;headerRow\&quot; will always contain \&quot;observationUnitDbId\&quot; and any or all of the OPTIONAL column header names.  The second array \&quot;observationVariables\&quot; contains the names and DbIds for the Observation Variables represented in the table.  By appending the two arrays, you can construct the complete header row of the table. &lt;/p&gt; &lt;p&gt;For CSV and TSV representations of the table, an extra header row is needed to describe both the Observation Variable DbId and the Observation Variable Name for each data column.  See the example responses below&lt;/p&gt; 
     * @param accept The requested content type which should be returned by the server (required)
     * @param observationUnitDbId The unique ID of an Observation Unit (optional)
     * @param germplasmDbId The unique ID of a germplasm (accession) to filter on (optional)
     * @param observationVariableDbId The unique ID of an observation variable (optional)
     * @param studyDbId The unique ID of a studies to filter on (optional)
     * @param locationDbId The unique ID of a location where these observations were collected (optional)
     * @param trialDbId The unique ID of a trial to filter on (optional)
     * @param programDbId The unique ID of a program to filter on (optional)
     * @param seasonDbId The year or Phenotyping campaign of a multi-annual study (trees, grape, ...) (optional)
     * @param observationLevel The type of the observationUnit. Returns only the observation unit of the specified type; the parent levels ID can be accessed through observationUnitStructure. (optional)
     * @param searchResultsDbId Permanent unique identifier which references the search results (optional)
     * @param observationTimeStampRangeStart Timestamp range start (optional)
     * @param observationTimeStampRangeEnd Timestamp range end (optional)
     * @param authorization HTTP HEADER - Token used for Authorization   &lt;strong&gt; Bearer {token_string} &lt;/strong&gt; (optional)
     * @return ApiResponse&lt;ObservationTableResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<ObservationTableResponse> observationsTableGetWithHttpInfo(WSMIMEDataTypes accept, String observationUnitDbId, String germplasmDbId, String observationVariableDbId, String studyDbId, String locationDbId, String trialDbId, String programDbId, String seasonDbId, String observationLevel, String searchResultsDbId, OffsetDateTime observationTimeStampRangeStart, OffsetDateTime observationTimeStampRangeEnd, String authorization) throws ApiException {
        Call call = observationsTableGetValidateBeforeCall(accept, observationUnitDbId, germplasmDbId, observationVariableDbId, studyDbId, locationDbId, trialDbId, programDbId, seasonDbId, observationLevel, searchResultsDbId, observationTimeStampRangeStart, observationTimeStampRangeEnd, authorization, null, null);
        Type localVarReturnType = new TypeToken<ObservationTableResponse>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Get a list of Observations in a table format (asynchronously)
     * &lt;p&gt;This service is designed to retrieve a table of time dependant observation values as a matrix of Observation Units and Observation Variables. This is also sometimes called a Time Series. This service takes the \&quot;Sparse Table\&quot; approach for representing this time dependant data.&lt;/p&gt; &lt;p&gt;The table may be represented by JSON, CSV, or TSV. The \&quot;Accept\&quot; HTTP header is used for the client to request different return formats.  By default, if the \&quot;Accept\&quot; header is not included in the request, the server should return JSON as described below.&lt;/p&gt; &lt;p&gt;The table is REQUIRED to have the following columns&lt;/p&gt; &lt;ul&gt;   &lt;li&gt;observationUnitDbId - Each row is related to one Observation Unit&lt;/li&gt;   &lt;li&gt;observationTimeStamp - Each row is has a time stamp for when the observation was taken&lt;/li&gt;   &lt;li&gt;At least one column with an observationVariableDbId&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;The table may have any or all of the following OPTIONAL columns. Included columns are decided by the server developer&lt;/p&gt; &lt;ul&gt;   &lt;li&gt;observationUnitName&lt;/li&gt;   &lt;li&gt;studyDbId&lt;/li&gt;   &lt;li&gt;studyName&lt;/li&gt;   &lt;li&gt;germplasmDbId&lt;/li&gt;   &lt;li&gt;germplasmName&lt;/li&gt;   &lt;li&gt;positionCoordinateX&lt;/li&gt;   &lt;li&gt;positionCoordinateY&lt;/li&gt;   &lt;li&gt;year&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;The table also may have any number of Observation Unit Hierarchy Level columns. For example:&lt;/p&gt; &lt;ul&gt;   &lt;li&gt;field&lt;/li&gt;   &lt;li&gt;plot&lt;/li&gt;   &lt;li&gt;sub-plot&lt;/li&gt;   &lt;li&gt;plant&lt;/li&gt;   &lt;li&gt;pot&lt;/li&gt;   &lt;li&gt;block&lt;/li&gt;   &lt;li&gt;entry&lt;/li&gt;   &lt;li&gt;rep&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;The JSON representation provides a pair of extra arrays for defining the headers of the table.  The first array \&quot;headerRow\&quot; will always contain \&quot;observationUnitDbId\&quot; and any or all of the OPTIONAL column header names.  The second array \&quot;observationVariables\&quot; contains the names and DbIds for the Observation Variables represented in the table.  By appending the two arrays, you can construct the complete header row of the table. &lt;/p&gt; &lt;p&gt;For CSV and TSV representations of the table, an extra header row is needed to describe both the Observation Variable DbId and the Observation Variable Name for each data column.  See the example responses below&lt;/p&gt; 
     * @param accept The requested content type which should be returned by the server (required)
     * @param observationUnitDbId The unique ID of an Observation Unit (optional)
     * @param germplasmDbId The unique ID of a germplasm (accession) to filter on (optional)
     * @param observationVariableDbId The unique ID of an observation variable (optional)
     * @param studyDbId The unique ID of a studies to filter on (optional)
     * @param locationDbId The unique ID of a location where these observations were collected (optional)
     * @param trialDbId The unique ID of a trial to filter on (optional)
     * @param programDbId The unique ID of a program to filter on (optional)
     * @param seasonDbId The year or Phenotyping campaign of a multi-annual study (trees, grape, ...) (optional)
     * @param observationLevel The type of the observationUnit. Returns only the observation unit of the specified type; the parent levels ID can be accessed through observationUnitStructure. (optional)
     * @param searchResultsDbId Permanent unique identifier which references the search results (optional)
     * @param observationTimeStampRangeStart Timestamp range start (optional)
     * @param observationTimeStampRangeEnd Timestamp range end (optional)
     * @param authorization HTTP HEADER - Token used for Authorization   &lt;strong&gt; Bearer {token_string} &lt;/strong&gt; (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public Call observationsTableGetAsync(WSMIMEDataTypes accept, String observationUnitDbId, String germplasmDbId, String observationVariableDbId, String studyDbId, String locationDbId, String trialDbId, String programDbId, String seasonDbId, String observationLevel, String searchResultsDbId, OffsetDateTime observationTimeStampRangeStart, OffsetDateTime observationTimeStampRangeEnd, String authorization, final ApiCallback<ObservationTableResponse> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        Call call = observationsTableGetValidateBeforeCall(accept, observationUnitDbId, germplasmDbId, observationVariableDbId, studyDbId, locationDbId, trialDbId, programDbId, seasonDbId, observationLevel, searchResultsDbId, observationTimeStampRangeStart, observationTimeStampRangeEnd, authorization, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<ObservationTableResponse>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for searchObservationsPost
     * @param body  (optional)
     * @param authorization HTTP HEADER - Token used for Authorization   &lt;strong&gt; Bearer {token_string} &lt;/strong&gt; (optional)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public Call searchObservationsPostCall(ObservationSearchRequest body, String authorization, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = body;
        
        // create path and map variables
        String localVarPath = "/search/observations";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        if (authorization != null)
        localVarHeaderParams.put("Authorization", apiClient.parameterToString(authorization));

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new Interceptor() {
                @Override
                public Response intercept(Interceptor.Chain chain) throws IOException {
                    Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "AuthorizationToken" };
        return apiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }
    
    @SuppressWarnings("rawtypes")
    private Call searchObservationsPostValidateBeforeCall(ObservationSearchRequest body, String authorization, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        Call call = searchObservationsPostCall(body, authorization, progressListener, progressRequestListener);
        return call;

        
        
        
        
    }

    /**
     * Submit a search request for a set of Observations
     * Submit a search request for a set of Observations. Returns an Id which reference the results of this search
     * @param body  (optional)
     * @param authorization HTTP HEADER - Token used for Authorization   &lt;strong&gt; Bearer {token_string} &lt;/strong&gt; (optional)
     * @return ObservationListResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ObservationListResponse searchObservationsPost(ObservationSearchRequest body, String authorization) throws ApiException {
        ApiResponse<ObservationListResponse> resp = searchObservationsPostWithHttpInfo(body, authorization);
        return resp.getData();
    }

    /**
     * Submit a search request for a set of Observations
     * Submit a search request for a set of Observations. Returns an Id which reference the results of this search
     * @param body  (optional)
     * @param authorization HTTP HEADER - Token used for Authorization   &lt;strong&gt; Bearer {token_string} &lt;/strong&gt; (optional)
     * @return ApiResponse&lt;ObservationListResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<ObservationListResponse> searchObservationsPostWithHttpInfo(ObservationSearchRequest body, String authorization) throws ApiException {
        Call call = searchObservationsPostValidateBeforeCall(body, authorization, null, null);
        Type localVarReturnType = new TypeToken<ObservationListResponse>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Submit a search request for a set of Observations (asynchronously)
     * Submit a search request for a set of Observations. Returns an Id which reference the results of this search
     * @param body  (optional)
     * @param authorization HTTP HEADER - Token used for Authorization   &lt;strong&gt; Bearer {token_string} &lt;/strong&gt; (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public Call searchObservationsPostAsync(ObservationSearchRequest body, String authorization, final ApiCallback<ObservationListResponse> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        Call call = searchObservationsPostValidateBeforeCall(body, authorization, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<ObservationListResponse>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for searchObservationsSearchResultsDbIdGet
     * @param accept The requested content type which should be returned by the server (required)
     * @param searchResultsDbId Unique identifier which references the search results (required)
     * @param authorization HTTP HEADER - Token used for Authorization   &lt;strong&gt; Bearer {token_string} &lt;/strong&gt; (optional)
     * @param page Used to request a specific page of data to be returned.  The page indexing starts at 0 (the first page is &#x27;page&#x27;&#x3D; 0). Default is &#x60;0&#x60;. (optional)
     * @param pageSize The size of the pages to be returned. Default is &#x60;1000&#x60;. (optional)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public Call searchObservationsSearchResultsDbIdGetCall(WSMIMEDataTypes accept, String searchResultsDbId, String authorization, Integer page, Integer pageSize, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // create path and map variables
        String localVarPath = "/search/observations/{searchResultsDbId}"
            .replaceAll("\\{" + "searchResultsDbId" + "\\}", apiClient.escapeString(searchResultsDbId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        if (page != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("page", page));
        if (pageSize != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("pageSize", pageSize));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        if (accept != null)
        localVarHeaderParams.put("Accept", apiClient.parameterToString(accept));
        if (authorization != null)
        localVarHeaderParams.put("Authorization", apiClient.parameterToString(authorization));

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new Interceptor() {
                @Override
                public Response intercept(Interceptor.Chain chain) throws IOException {
                    Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "AuthorizationToken" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }
    
    @SuppressWarnings("rawtypes")
    private Call searchObservationsSearchResultsDbIdGetValidateBeforeCall(WSMIMEDataTypes accept, String searchResultsDbId, String authorization, Integer page, Integer pageSize, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        // verify the required parameter 'accept' is set
        if (accept == null) {
            throw new ApiException("Missing the required parameter 'accept' when calling searchObservationsSearchResultsDbIdGet(Async)");
        }
        // verify the required parameter 'searchResultsDbId' is set
        if (searchResultsDbId == null) {
            throw new ApiException("Missing the required parameter 'searchResultsDbId' when calling searchObservationsSearchResultsDbIdGet(Async)");
        }
        
        Call call = searchObservationsSearchResultsDbIdGetCall(accept, searchResultsDbId, authorization, page, pageSize, progressListener, progressRequestListener);
        return call;

        
        
        
        
    }

    /**
     * Returns a list of Observations based on search criteria.
     * Returns a list of Observations based on search criteria.  observationTimeStamp - Iso Standard 8601.  observationValue data type inferred from the ontology
     * @param accept The requested content type which should be returned by the server (required)
     * @param searchResultsDbId Unique identifier which references the search results (required)
     * @param authorization HTTP HEADER - Token used for Authorization   &lt;strong&gt; Bearer {token_string} &lt;/strong&gt; (optional)
     * @param page Used to request a specific page of data to be returned.  The page indexing starts at 0 (the first page is &#x27;page&#x27;&#x3D; 0). Default is &#x60;0&#x60;. (optional)
     * @param pageSize The size of the pages to be returned. Default is &#x60;1000&#x60;. (optional)
     * @return ObservationListResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ObservationListResponse searchObservationsSearchResultsDbIdGet(WSMIMEDataTypes accept, String searchResultsDbId, String authorization, Integer page, Integer pageSize) throws ApiException {
        ApiResponse<ObservationListResponse> resp = searchObservationsSearchResultsDbIdGetWithHttpInfo(accept, searchResultsDbId, authorization, page, pageSize);
        return resp.getData();
    }

    /**
     * Returns a list of Observations based on search criteria.
     * Returns a list of Observations based on search criteria.  observationTimeStamp - Iso Standard 8601.  observationValue data type inferred from the ontology
     * @param accept The requested content type which should be returned by the server (required)
     * @param searchResultsDbId Unique identifier which references the search results (required)
     * @param authorization HTTP HEADER - Token used for Authorization   &lt;strong&gt; Bearer {token_string} &lt;/strong&gt; (optional)
     * @param page Used to request a specific page of data to be returned.  The page indexing starts at 0 (the first page is &#x27;page&#x27;&#x3D; 0). Default is &#x60;0&#x60;. (optional)
     * @param pageSize The size of the pages to be returned. Default is &#x60;1000&#x60;. (optional)
     * @return ApiResponse&lt;ObservationListResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<ObservationListResponse> searchObservationsSearchResultsDbIdGetWithHttpInfo(WSMIMEDataTypes accept, String searchResultsDbId, String authorization, Integer page, Integer pageSize) throws ApiException {
        Call call = searchObservationsSearchResultsDbIdGetValidateBeforeCall(accept, searchResultsDbId, authorization, page, pageSize, null, null);
        Type localVarReturnType = new TypeToken<ObservationListResponse>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Returns a list of Observations based on search criteria. (asynchronously)
     * Returns a list of Observations based on search criteria.  observationTimeStamp - Iso Standard 8601.  observationValue data type inferred from the ontology
     * @param accept The requested content type which should be returned by the server (required)
     * @param searchResultsDbId Unique identifier which references the search results (required)
     * @param authorization HTTP HEADER - Token used for Authorization   &lt;strong&gt; Bearer {token_string} &lt;/strong&gt; (optional)
     * @param page Used to request a specific page of data to be returned.  The page indexing starts at 0 (the first page is &#x27;page&#x27;&#x3D; 0). Default is &#x60;0&#x60;. (optional)
     * @param pageSize The size of the pages to be returned. Default is &#x60;1000&#x60;. (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public Call searchObservationsSearchResultsDbIdGetAsync(WSMIMEDataTypes accept, String searchResultsDbId, String authorization, Integer page, Integer pageSize, final ApiCallback<ObservationListResponse> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        Call call = searchObservationsSearchResultsDbIdGetValidateBeforeCall(accept, searchResultsDbId, authorization, page, pageSize, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<ObservationListResponse>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
}
