/*
 * BrAPI-Core
 * The Breeding API (BrAPI) is a Standardized REST ful Web Service API Specification for communicating Plant Breeding Data. BrAPI allows for easy data sharing between databases and tools involved in plant breeding. <div class=\"brapi-section\"> <h2 class=\"brapi-section-title\">General Reference Documentation</h2> <div class=\"gen-info-link\"><a href=\"https://github.com/plantbreeding/API/blob/master/Specification/GeneralInfo/URL_Structure.md\">URL Structure</a></div> <div class=\"gen-info-link\"><a href=\"https://github.com/plantbreeding/API/blob/master/Specification/GeneralInfo/Response_Structure.md\">Response Structure</a></div> <div class=\"gen-info-link\"><a href=\"https://github.com/plantbreeding/API/blob/master/Specification/GeneralInfo/Date_Time_Encoding.md\">Date/Time Encoding</a></div> <div class=\"gen-info-link\"><a href=\"https://github.com/plantbreeding/API/blob/master/Specification/GeneralInfo/Location_Encoding.md\">Location Encoding</a></div> <div class=\"gen-info-link\"><a href=\"https://github.com/plantbreeding/API/blob/master/Specification/GeneralInfo/Error_Handling.md\">Error Handling</a></div> <div class=\"gen-info-link\"><a href=\"https://github.com/plantbreeding/API/blob/master/Specification/GeneralInfo/Search_Services.md\">Search Services</a></div> </div>  <div class=\"current-brapi-section brapi-section\"> <h2 class=\"brapi-section-title\">BrAPI Core</h2> <div class=\"brapi-section-description\">The BrAPI Core module contains high level entities used for organization and management. This includes Programs, Trials, Studies, Locations, People, and Lists</div> <div class=\"version-number\">V2.0</div> <div class=\"link-btn\"><a href=\"https://github.com/plantbreeding/API/tree/master/Specification/BrAPI-Core\">GitHub</a></div> <div class=\"link-btn\"><a href=\"https://app.swaggerhub.com/apis/PlantBreedingAPI/BrAPI-Core\">SwaggerHub</a></div> <div class=\"link-btn\"><a href=\"https://brapicore.docs.apiary.io\">Apiary</a></div> <div class=\"stop-float\"></div> </div>  <div class=\"brapi-section\"> <h2 class=\"brapi-section-title\">BrAPI Phenotyping</h2> <div class=\"brapi-section-description\">The BrAPI Phenotyping module contains entities related to phenotypic observations. This includes Observation Units, Observations, Observation Variables, Traits, Scales, Methods, and Images</div> <div class=\"version-number\">V2.0</div> <div class=\"link-btn\"><a href=\"https://github.com/plantbreeding/API/tree/master/Specification/BrAPI-Phenotyping\">GitHub</a></div> <div class=\"link-btn\"><a href=\"https://app.swaggerhub.com/apis/PlantBreedingAPI/BrAPI-Phenotyping\">SwaggerHub</a></div> <div class=\"link-btn\"><a href=\"https://brapiphenotyping.docs.apiary.io\">Apiary</a></div> <div class=\"stop-float\"></div> </div>  <div class=\"brapi-section\"> <h2 class=\"brapi-section-title\">BrAPI Genotyping</h2> <div class=\"brapi-section-description\">The BrAPI Genotyping module contains entities related to genotyping analysis. This includes Samples, Markers, Variant Sets, Variants, Call Sets, Calls, References, Reads, and Vendor Orders</div> <div class=\"version-number\">V2.0</div> <div class=\"link-btn\"><a href=\"https://github.com/plantbreeding/API/tree/master/Specification/BrAPI-Genotyping\">GitHub</a></div> <div class=\"link-btn\"><a href=\"https://app.swaggerhub.com/apis/PlantBreedingAPI/BrAPI-Genotyping\">SwaggerHub</a></div> <div class=\"link-btn\"><a href=\"https://brapigenotyping.docs.apiary.io\">Apiary</a></div> <div class=\"stop-float\"></div> </div>  <div class=\"brapi-section\"> <h2 class=\"brapi-section-title\">BrAPI Germplasm</h2> <div class=\"brapi-section-description\">The BrAPI Germplasm module contains entities related to germplasm management. This includes Germplasm, Germplasm Attributes, Seed Lots, Crosses, Pedigree, and Progeny</div> <div class=\"version-number\">V2.0</div> <div class=\"link-btn\"><a href=\"https://github.com/plantbreeding/API/tree/master/Specification/BrAPI-Germplasm\">GitHub</a></div> <div class=\"link-btn\"><a href=\"https://app.swaggerhub.com/apis/PlantBreedingAPI/BrAPI-Germplasm\">SwaggerHub</a></div> <div class=\"link-btn\"><a href=\"https://brapigermplasm.docs.apiary.io\">Apiary</a></div> <div class=\"stop-float\"></div> </div>  <style> .link-btn{ float: left;  margin: 2px 10px 0 0;  padding: 0 5px;  border-radius: 5px;  background-color: #ddd; } .stop-float{   clear: both; } .version-number{   float: left;    margin: 5px 10px 0 5px; } .brapi-section-title{   margin: 0 10px 0 0;   font-size: 20px; } .current-brapi-section{   font-weight: bolder;   border-radius: 5px;    background-color: #ddd; } .brapi-section{   padding: 5px 5px;  } .brapi-section-description{   margin: 5px 0 0 5px; } </style>
 *
 * OpenAPI spec version: 2.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package io.swagger.client.org.brapi.client.api.core;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;

import okhttp3.Call;
import okhttp3.Interceptor;
import okhttp3.Response;

import io.swagger.client.model.Model202AcceptedSearchResponse;
import io.swagger.client.org.brapi.client.ApiCallback;
import io.swagger.client.org.brapi.client.ApiException;
import io.swagger.client.org.brapi.client.ApiResponse;
import io.swagger.client.org.brapi.client.Pair;
import io.swagger.client.org.brapi.client.ProgressRequestBody;
import io.swagger.client.org.brapi.client.ApiClient;
import io.swagger.client.org.brapi.client.Configuration;
import io.swagger.client.org.brapi.client.ProgressResponseBody;
import io.swagger.client.model.core.StudyListResponse;
import io.swagger.client.model.core.StudyNewRequest;
import io.swagger.client.model.core.StudySearchRequest;
import io.swagger.client.model.core.StudySingleResponse;
import io.swagger.client.model.core.StudyTypesResponse;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class StudiesApi {
    private ApiClient apiClient;

    public StudiesApi() {
        this(Configuration.getDefaultApiClient());
    }

    public StudiesApi(ApiClient apiClient) {
        this.apiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return apiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.apiClient = apiClient;
    }

    /**
     * Build call for searchStudiesPost
     * @param body Study Search request (optional)
     * @param authorization HTTP HEADER - Token used for Authorization   &lt;strong&gt; Bearer {token_string} &lt;/strong&gt; (optional)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public Call searchStudiesPostCall(StudySearchRequest body, String authorization, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = body;
        
        // create path and map variables
        String localVarPath = "/search/studies";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        if (authorization != null)
        localVarHeaderParams.put("Authorization", apiClient.parameterToString(authorization));

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new Interceptor() {
                @Override
                public Response intercept(Interceptor.Chain chain) throws IOException {
                    Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "AuthorizationToken" };
        return apiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }
    
    @SuppressWarnings("rawtypes")
    private Call searchStudiesPostValidateBeforeCall(StudySearchRequest body, String authorization, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        Call call = searchStudiesPostCall(body, authorization, progressListener, progressRequestListener);
        return call;

        
        
        
        
    }

    /**
     * Submit a search request for Studies
     * Get list of studies StartDate and endDate should be ISO-8601 format for dates See Search Services for additional implementation details.
     * @param body Study Search request (optional)
     * @param authorization HTTP HEADER - Token used for Authorization   &lt;strong&gt; Bearer {token_string} &lt;/strong&gt; (optional)
     * @return StudyListResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public StudyListResponse searchStudiesPost(StudySearchRequest body, String authorization) throws ApiException {
        ApiResponse<StudyListResponse> resp = searchStudiesPostWithHttpInfo(body, authorization);
        return resp.getData();
    }

    /**
     * Submit a search request for Studies
     * Get list of studies StartDate and endDate should be ISO-8601 format for dates See Search Services for additional implementation details.
     * @param body Study Search request (optional)
     * @param authorization HTTP HEADER - Token used for Authorization   &lt;strong&gt; Bearer {token_string} &lt;/strong&gt; (optional)
     * @return ApiResponse&lt;StudyListResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<StudyListResponse> searchStudiesPostWithHttpInfo(StudySearchRequest body, String authorization) throws ApiException {
        Call call = searchStudiesPostValidateBeforeCall(body, authorization, null, null);
        Type localVarReturnType = new TypeToken<StudyListResponse>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Submit a search request for Studies (asynchronously)
     * Get list of studies StartDate and endDate should be ISO-8601 format for dates See Search Services for additional implementation details.
     * @param body Study Search request (optional)
     * @param authorization HTTP HEADER - Token used for Authorization   &lt;strong&gt; Bearer {token_string} &lt;/strong&gt; (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public Call searchStudiesPostAsync(StudySearchRequest body, String authorization, final ApiCallback<StudyListResponse> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        Call call = searchStudiesPostValidateBeforeCall(body, authorization, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<StudyListResponse>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for searchStudiesSearchResultsDbIdGet
     * @param searchResultsDbId Unique identifier which references the search results (required)
     * @param page Used to request a specific page of data to be returned.  The page indexing starts at 0 (the first page is &#x27;page&#x27;&#x3D; 0). Default is &#x60;0&#x60;. (optional)
     * @param pageSize The size of the pages to be returned. Default is &#x60;1000&#x60;. (optional)
     * @param authorization HTTP HEADER - Token used for Authorization   &lt;strong&gt; Bearer {token_string} &lt;/strong&gt; (optional)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public Call searchStudiesSearchResultsDbIdGetCall(String searchResultsDbId, Integer page, Integer pageSize, String authorization, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // create path and map variables
        String localVarPath = "/search/studies/{searchResultsDbId}"
            .replaceAll("\\{" + "searchResultsDbId" + "\\}", apiClient.escapeString(searchResultsDbId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        if (page != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("page", page));
        if (pageSize != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("pageSize", pageSize));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        if (authorization != null)
        localVarHeaderParams.put("Authorization", apiClient.parameterToString(authorization));

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new Interceptor() {
                @Override
                public Response intercept(Interceptor.Chain chain) throws IOException {
                    Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "AuthorizationToken" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }
    
    @SuppressWarnings("rawtypes")
    private Call searchStudiesSearchResultsDbIdGetValidateBeforeCall(String searchResultsDbId, Integer page, Integer pageSize, String authorization, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        // verify the required parameter 'searchResultsDbId' is set
        if (searchResultsDbId == null) {
            throw new ApiException("Missing the required parameter 'searchResultsDbId' when calling searchStudiesSearchResultsDbIdGet(Async)");
        }
        
        Call call = searchStudiesSearchResultsDbIdGetCall(searchResultsDbId, page, pageSize, authorization, progressListener, progressRequestListener);
        return call;

        
        
        
        
    }

    /**
     * Get the results of a Studies search request
     * Get list of studies  StartDate and endDate should be ISO-8601 format for dates  See Search Services for additional implementation details.
     * @param searchResultsDbId Unique identifier which references the search results (required)
     * @param page Used to request a specific page of data to be returned.  The page indexing starts at 0 (the first page is &#x27;page&#x27;&#x3D; 0). Default is &#x60;0&#x60;. (optional)
     * @param pageSize The size of the pages to be returned. Default is &#x60;1000&#x60;. (optional)
     * @param authorization HTTP HEADER - Token used for Authorization   &lt;strong&gt; Bearer {token_string} &lt;/strong&gt; (optional)
     * @return StudyListResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public StudyListResponse searchStudiesSearchResultsDbIdGet(String searchResultsDbId, Integer page, Integer pageSize, String authorization) throws ApiException {
        ApiResponse<StudyListResponse> resp = searchStudiesSearchResultsDbIdGetWithHttpInfo(searchResultsDbId, page, pageSize, authorization);
        return resp.getData();
    }

    /**
     * Get the results of a Studies search request
     * Get list of studies  StartDate and endDate should be ISO-8601 format for dates  See Search Services for additional implementation details.
     * @param searchResultsDbId Unique identifier which references the search results (required)
     * @param page Used to request a specific page of data to be returned.  The page indexing starts at 0 (the first page is &#x27;page&#x27;&#x3D; 0). Default is &#x60;0&#x60;. (optional)
     * @param pageSize The size of the pages to be returned. Default is &#x60;1000&#x60;. (optional)
     * @param authorization HTTP HEADER - Token used for Authorization   &lt;strong&gt; Bearer {token_string} &lt;/strong&gt; (optional)
     * @return ApiResponse&lt;StudyListResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<StudyListResponse> searchStudiesSearchResultsDbIdGetWithHttpInfo(String searchResultsDbId, Integer page, Integer pageSize, String authorization) throws ApiException {
        Call call = searchStudiesSearchResultsDbIdGetValidateBeforeCall(searchResultsDbId, page, pageSize, authorization, null, null);
        Type localVarReturnType = new TypeToken<StudyListResponse>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Get the results of a Studies search request (asynchronously)
     * Get list of studies  StartDate and endDate should be ISO-8601 format for dates  See Search Services for additional implementation details.
     * @param searchResultsDbId Unique identifier which references the search results (required)
     * @param page Used to request a specific page of data to be returned.  The page indexing starts at 0 (the first page is &#x27;page&#x27;&#x3D; 0). Default is &#x60;0&#x60;. (optional)
     * @param pageSize The size of the pages to be returned. Default is &#x60;1000&#x60;. (optional)
     * @param authorization HTTP HEADER - Token used for Authorization   &lt;strong&gt; Bearer {token_string} &lt;/strong&gt; (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public Call searchStudiesSearchResultsDbIdGetAsync(String searchResultsDbId, Integer page, Integer pageSize, String authorization, final ApiCallback<StudyListResponse> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        Call call = searchStudiesSearchResultsDbIdGetValidateBeforeCall(searchResultsDbId, page, pageSize, authorization, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<StudyListResponse>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for studiesGet
     * @param commonCropName Common name for the crop associated with this study (optional)
     * @param studyType Filter based on study type unique identifier (optional)
     * @param programDbId Program filter to only return studies associated with given program id. (optional)
     * @param locationDbId Filter by location (optional)
     * @param seasonDbId Filter by season or year (optional)
     * @param trialDbId Filter by trial (optional)
     * @param studyDbId Filter by study DbId (optional)
     * @param studyName Filter by study name (optional)
     * @param studyCode Filter by study code (optional)
     * @param studyPUI Filter by study PUI (optional)
     * @param germplasmDbId Filter by germplasm DbId (optional)
     * @param observationVariableDbId Filter by observation variable DbId (optional)
     * @param active Filter active status true/false. (optional)
     * @param sortBy Name of the field to sort by. (optional)
     * @param sortOrder Sort order direction. Ascending/Descending. (optional)
     * @param externalReferenceID An external reference ID. Could be a simple string or a URI. (use with &#x60;externalReferenceSource&#x60; parameter) (optional)
     * @param externalReferenceSource An identifier for the source system or database of an external reference (use with &#x60;externalReferenceID&#x60; parameter) (optional)
     * @param page Used to request a specific page of data to be returned.  The page indexing starts at 0 (the first page is &#x27;page&#x27;&#x3D; 0). Default is &#x60;0&#x60;. (optional)
     * @param pageSize The size of the pages to be returned. Default is &#x60;1000&#x60;. (optional)
     * @param authorization HTTP HEADER - Token used for Authorization   &lt;strong&gt; Bearer {token_string} &lt;/strong&gt; (optional)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public Call studiesGetCall(String commonCropName, String studyType, String programDbId, String locationDbId, String seasonDbId, String trialDbId, String studyDbId, String studyName, String studyCode, String studyPUI, String germplasmDbId, String observationVariableDbId, Boolean active, String sortBy, String sortOrder, String externalReferenceID, String externalReferenceSource, Integer page, Integer pageSize, String authorization, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // create path and map variables
        String localVarPath = "/studies";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        if (commonCropName != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("commonCropName", commonCropName));
        if (studyType != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("studyType", studyType));
        if (programDbId != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("programDbId", programDbId));
        if (locationDbId != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("locationDbId", locationDbId));
        if (seasonDbId != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("seasonDbId", seasonDbId));
        if (trialDbId != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("trialDbId", trialDbId));
        if (studyDbId != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("studyDbId", studyDbId));
        if (studyName != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("studyName", studyName));
        if (studyCode != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("studyCode", studyCode));
        if (studyPUI != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("studyPUI", studyPUI));
        if (germplasmDbId != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("germplasmDbId", germplasmDbId));
        if (observationVariableDbId != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("observationVariableDbId", observationVariableDbId));
        if (active != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("active", active));
        if (sortBy != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("sortBy", sortBy));
        if (sortOrder != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("sortOrder", sortOrder));
        if (externalReferenceID != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("externalReferenceID", externalReferenceID));
        if (externalReferenceSource != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("externalReferenceSource", externalReferenceSource));
        if (page != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("page", page));
        if (pageSize != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("pageSize", pageSize));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        if (authorization != null)
        localVarHeaderParams.put("Authorization", apiClient.parameterToString(authorization));

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new Interceptor() {
                @Override
                public Response intercept(Interceptor.Chain chain) throws IOException {
                    Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "AuthorizationToken" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }
    
    @SuppressWarnings("rawtypes")
    private Call studiesGetValidateBeforeCall(String commonCropName, String studyType, String programDbId, String locationDbId, String seasonDbId, String trialDbId, String studyDbId, String studyName, String studyCode, String studyPUI, String germplasmDbId, String observationVariableDbId, Boolean active, String sortBy, String sortOrder, String externalReferenceID, String externalReferenceSource, Integer page, Integer pageSize, String authorization, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        Call call = studiesGetCall(commonCropName, studyType, programDbId, locationDbId, seasonDbId, trialDbId, studyDbId, studyName, studyCode, studyPUI, germplasmDbId, observationVariableDbId, active, sortBy, sortOrder, externalReferenceID, externalReferenceSource, page, pageSize, authorization, progressListener, progressRequestListener);
        return call;

        
        
        
        
    }

    /**
     * Get a filtered list of Studies
     * Get list of studies  StartDate and endDate should be ISO-8601 format for dates
     * @param commonCropName Common name for the crop associated with this study (optional)
     * @param studyType Filter based on study type unique identifier (optional)
     * @param programDbId Program filter to only return studies associated with given program id. (optional)
     * @param locationDbId Filter by location (optional)
     * @param seasonDbId Filter by season or year (optional)
     * @param trialDbId Filter by trial (optional)
     * @param studyDbId Filter by study DbId (optional)
     * @param studyName Filter by study name (optional)
     * @param studyCode Filter by study code (optional)
     * @param studyPUI Filter by study PUI (optional)
     * @param germplasmDbId Filter by germplasm DbId (optional)
     * @param observationVariableDbId Filter by observation variable DbId (optional)
     * @param active Filter active status true/false. (optional)
     * @param sortBy Name of the field to sort by. (optional)
     * @param sortOrder Sort order direction. Ascending/Descending. (optional)
     * @param externalReferenceID An external reference ID. Could be a simple string or a URI. (use with &#x60;externalReferenceSource&#x60; parameter) (optional)
     * @param externalReferenceSource An identifier for the source system or database of an external reference (use with &#x60;externalReferenceID&#x60; parameter) (optional)
     * @param page Used to request a specific page of data to be returned.  The page indexing starts at 0 (the first page is &#x27;page&#x27;&#x3D; 0). Default is &#x60;0&#x60;. (optional)
     * @param pageSize The size of the pages to be returned. Default is &#x60;1000&#x60;. (optional)
     * @param authorization HTTP HEADER - Token used for Authorization   &lt;strong&gt; Bearer {token_string} &lt;/strong&gt; (optional)
     * @return StudyListResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public StudyListResponse studiesGet(String commonCropName, String studyType, String programDbId, String locationDbId, String seasonDbId, String trialDbId, String studyDbId, String studyName, String studyCode, String studyPUI, String germplasmDbId, String observationVariableDbId, Boolean active, String sortBy, String sortOrder, String externalReferenceID, String externalReferenceSource, Integer page, Integer pageSize, String authorization) throws ApiException {
        ApiResponse<StudyListResponse> resp = studiesGetWithHttpInfo(commonCropName, studyType, programDbId, locationDbId, seasonDbId, trialDbId, studyDbId, studyName, studyCode, studyPUI, germplasmDbId, observationVariableDbId, active, sortBy, sortOrder, externalReferenceID, externalReferenceSource, page, pageSize, authorization);
        return resp.getData();
    }

    /**
     * Get a filtered list of Studies
     * Get list of studies  StartDate and endDate should be ISO-8601 format for dates
     * @param commonCropName Common name for the crop associated with this study (optional)
     * @param studyType Filter based on study type unique identifier (optional)
     * @param programDbId Program filter to only return studies associated with given program id. (optional)
     * @param locationDbId Filter by location (optional)
     * @param seasonDbId Filter by season or year (optional)
     * @param trialDbId Filter by trial (optional)
     * @param studyDbId Filter by study DbId (optional)
     * @param studyName Filter by study name (optional)
     * @param studyCode Filter by study code (optional)
     * @param studyPUI Filter by study PUI (optional)
     * @param germplasmDbId Filter by germplasm DbId (optional)
     * @param observationVariableDbId Filter by observation variable DbId (optional)
     * @param active Filter active status true/false. (optional)
     * @param sortBy Name of the field to sort by. (optional)
     * @param sortOrder Sort order direction. Ascending/Descending. (optional)
     * @param externalReferenceID An external reference ID. Could be a simple string or a URI. (use with &#x60;externalReferenceSource&#x60; parameter) (optional)
     * @param externalReferenceSource An identifier for the source system or database of an external reference (use with &#x60;externalReferenceID&#x60; parameter) (optional)
     * @param page Used to request a specific page of data to be returned.  The page indexing starts at 0 (the first page is &#x27;page&#x27;&#x3D; 0). Default is &#x60;0&#x60;. (optional)
     * @param pageSize The size of the pages to be returned. Default is &#x60;1000&#x60;. (optional)
     * @param authorization HTTP HEADER - Token used for Authorization   &lt;strong&gt; Bearer {token_string} &lt;/strong&gt; (optional)
     * @return ApiResponse&lt;StudyListResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<StudyListResponse> studiesGetWithHttpInfo(String commonCropName, String studyType, String programDbId, String locationDbId, String seasonDbId, String trialDbId, String studyDbId, String studyName, String studyCode, String studyPUI, String germplasmDbId, String observationVariableDbId, Boolean active, String sortBy, String sortOrder, String externalReferenceID, String externalReferenceSource, Integer page, Integer pageSize, String authorization) throws ApiException {
        Call call = studiesGetValidateBeforeCall(commonCropName, studyType, programDbId, locationDbId, seasonDbId, trialDbId, studyDbId, studyName, studyCode, studyPUI, germplasmDbId, observationVariableDbId, active, sortBy, sortOrder, externalReferenceID, externalReferenceSource, page, pageSize, authorization, null, null);
        Type localVarReturnType = new TypeToken<StudyListResponse>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Get a filtered list of Studies (asynchronously)
     * Get list of studies  StartDate and endDate should be ISO-8601 format for dates
     * @param commonCropName Common name for the crop associated with this study (optional)
     * @param studyType Filter based on study type unique identifier (optional)
     * @param programDbId Program filter to only return studies associated with given program id. (optional)
     * @param locationDbId Filter by location (optional)
     * @param seasonDbId Filter by season or year (optional)
     * @param trialDbId Filter by trial (optional)
     * @param studyDbId Filter by study DbId (optional)
     * @param studyName Filter by study name (optional)
     * @param studyCode Filter by study code (optional)
     * @param studyPUI Filter by study PUI (optional)
     * @param germplasmDbId Filter by germplasm DbId (optional)
     * @param observationVariableDbId Filter by observation variable DbId (optional)
     * @param active Filter active status true/false. (optional)
     * @param sortBy Name of the field to sort by. (optional)
     * @param sortOrder Sort order direction. Ascending/Descending. (optional)
     * @param externalReferenceID An external reference ID. Could be a simple string or a URI. (use with &#x60;externalReferenceSource&#x60; parameter) (optional)
     * @param externalReferenceSource An identifier for the source system or database of an external reference (use with &#x60;externalReferenceID&#x60; parameter) (optional)
     * @param page Used to request a specific page of data to be returned.  The page indexing starts at 0 (the first page is &#x27;page&#x27;&#x3D; 0). Default is &#x60;0&#x60;. (optional)
     * @param pageSize The size of the pages to be returned. Default is &#x60;1000&#x60;. (optional)
     * @param authorization HTTP HEADER - Token used for Authorization   &lt;strong&gt; Bearer {token_string} &lt;/strong&gt; (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public Call studiesGetAsync(String commonCropName, String studyType, String programDbId, String locationDbId, String seasonDbId, String trialDbId, String studyDbId, String studyName, String studyCode, String studyPUI, String germplasmDbId, String observationVariableDbId, Boolean active, String sortBy, String sortOrder, String externalReferenceID, String externalReferenceSource, Integer page, Integer pageSize, String authorization, final ApiCallback<StudyListResponse> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        Call call = studiesGetValidateBeforeCall(commonCropName, studyType, programDbId, locationDbId, seasonDbId, trialDbId, studyDbId, studyName, studyCode, studyPUI, germplasmDbId, observationVariableDbId, active, sortBy, sortOrder, externalReferenceID, externalReferenceSource, page, pageSize, authorization, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<StudyListResponse>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for studiesPost
     * @param body  (optional)
     * @param authorization HTTP HEADER - Token used for Authorization   &lt;strong&gt; Bearer {token_string} &lt;/strong&gt; (optional)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public Call studiesPostCall(List<StudyNewRequest> body, String authorization, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = body;
        
        // create path and map variables
        String localVarPath = "/studies";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        if (authorization != null)
        localVarHeaderParams.put("Authorization", apiClient.parameterToString(authorization));

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new Interceptor() {
                @Override
                public Response intercept(Interceptor.Chain chain) throws IOException {
                    Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "AuthorizationToken" };
        return apiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }
    
    @SuppressWarnings("rawtypes")
    private Call studiesPostValidateBeforeCall(List<StudyNewRequest> body, String authorization, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        Call call = studiesPostCall(body, authorization, progressListener, progressRequestListener);
        return call;

        
        
        
        
    }

    /**
     * Create new Studies.
     * Create new studies  Implementation Notes  StartDate and endDate should be ISO-8601 format for dates  &#x60;studDbId&#x60; is generated by the server.
     * @param body  (optional)
     * @param authorization HTTP HEADER - Token used for Authorization   &lt;strong&gt; Bearer {token_string} &lt;/strong&gt; (optional)
     * @return StudyListResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public StudyListResponse studiesPost(List<StudyNewRequest> body, String authorization) throws ApiException {
        ApiResponse<StudyListResponse> resp = studiesPostWithHttpInfo(body, authorization);
        return resp.getData();
    }

    /**
     * Create new Studies.
     * Create new studies  Implementation Notes  StartDate and endDate should be ISO-8601 format for dates  &#x60;studDbId&#x60; is generated by the server.
     * @param body  (optional)
     * @param authorization HTTP HEADER - Token used for Authorization   &lt;strong&gt; Bearer {token_string} &lt;/strong&gt; (optional)
     * @return ApiResponse&lt;StudyListResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<StudyListResponse> studiesPostWithHttpInfo(List<StudyNewRequest> body, String authorization) throws ApiException {
        Call call = studiesPostValidateBeforeCall(body, authorization, null, null);
        Type localVarReturnType = new TypeToken<StudyListResponse>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Create new Studies. (asynchronously)
     * Create new studies  Implementation Notes  StartDate and endDate should be ISO-8601 format for dates  &#x60;studDbId&#x60; is generated by the server.
     * @param body  (optional)
     * @param authorization HTTP HEADER - Token used for Authorization   &lt;strong&gt; Bearer {token_string} &lt;/strong&gt; (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public Call studiesPostAsync(List<StudyNewRequest> body, String authorization, final ApiCallback<StudyListResponse> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        Call call = studiesPostValidateBeforeCall(body, authorization, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<StudyListResponse>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for studiesStudyDbIdGet
     * @param studyDbId Identifier of the study. Usually a number, could be alphanumeric. (required)
     * @param authorization HTTP HEADER - Token used for Authorization   &lt;strong&gt; Bearer {token_string} &lt;/strong&gt; (optional)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public Call studiesStudyDbIdGetCall(String studyDbId, String authorization, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // create path and map variables
        String localVarPath = "/studies/{studyDbId}"
            .replaceAll("\\{" + "studyDbId" + "\\}", apiClient.escapeString(studyDbId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        if (authorization != null)
        localVarHeaderParams.put("Authorization", apiClient.parameterToString(authorization));

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new Interceptor() {
                @Override
                public Response intercept(Interceptor.Chain chain) throws IOException {
                    Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "AuthorizationToken" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }
    
    @SuppressWarnings("rawtypes")
    private Call studiesStudyDbIdGetValidateBeforeCall(String studyDbId, String authorization, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        // verify the required parameter 'studyDbId' is set
        if (studyDbId == null) {
            throw new ApiException("Missing the required parameter 'studyDbId' when calling studiesStudyDbIdGet(Async)");
        }
        
        Call call = studiesStudyDbIdGetCall(studyDbId, authorization, progressListener, progressRequestListener);
        return call;

        
        
        
        
    }

    /**
     * Get the details for a specific Study
     * Retrieve the information of the study required for field data collection  An additionalInfo field was added to provide a controlled vocabulary for less common data fields.
     * @param studyDbId Identifier of the study. Usually a number, could be alphanumeric. (required)
     * @param authorization HTTP HEADER - Token used for Authorization   &lt;strong&gt; Bearer {token_string} &lt;/strong&gt; (optional)
     * @return StudySingleResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public StudySingleResponse studiesStudyDbIdGet(String studyDbId, String authorization) throws ApiException {
        ApiResponse<StudySingleResponse> resp = studiesStudyDbIdGetWithHttpInfo(studyDbId, authorization);
        return resp.getData();
    }

    /**
     * Get the details for a specific Study
     * Retrieve the information of the study required for field data collection  An additionalInfo field was added to provide a controlled vocabulary for less common data fields.
     * @param studyDbId Identifier of the study. Usually a number, could be alphanumeric. (required)
     * @param authorization HTTP HEADER - Token used for Authorization   &lt;strong&gt; Bearer {token_string} &lt;/strong&gt; (optional)
     * @return ApiResponse&lt;StudySingleResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<StudySingleResponse> studiesStudyDbIdGetWithHttpInfo(String studyDbId, String authorization) throws ApiException {
        Call call = studiesStudyDbIdGetValidateBeforeCall(studyDbId, authorization, null, null);
        Type localVarReturnType = new TypeToken<StudySingleResponse>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Get the details for a specific Study (asynchronously)
     * Retrieve the information of the study required for field data collection  An additionalInfo field was added to provide a controlled vocabulary for less common data fields.
     * @param studyDbId Identifier of the study. Usually a number, could be alphanumeric. (required)
     * @param authorization HTTP HEADER - Token used for Authorization   &lt;strong&gt; Bearer {token_string} &lt;/strong&gt; (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public Call studiesStudyDbIdGetAsync(String studyDbId, String authorization, final ApiCallback<StudySingleResponse> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        Call call = studiesStudyDbIdGetValidateBeforeCall(studyDbId, authorization, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<StudySingleResponse>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for studiesStudyDbIdPut
     * @param studyDbId Identifier of the study. Usually a number, could be alphanumeric. (required)
     * @param body  (optional)
     * @param authorization HTTP HEADER - Token used for Authorization   &lt;strong&gt; Bearer {token_string} &lt;/strong&gt; (optional)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public Call studiesStudyDbIdPutCall(String studyDbId, StudyNewRequest body, String authorization, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = body;
        
        // create path and map variables
        String localVarPath = "/studies/{studyDbId}"
            .replaceAll("\\{" + "studyDbId" + "\\}", apiClient.escapeString(studyDbId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        if (authorization != null)
        localVarHeaderParams.put("Authorization", apiClient.parameterToString(authorization));

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new Interceptor() {
                @Override
                public Response intercept(Interceptor.Chain chain) throws IOException {
                    Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "AuthorizationToken" };
        return apiClient.buildCall(localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }
    
    @SuppressWarnings("rawtypes")
    private Call studiesStudyDbIdPutValidateBeforeCall(String studyDbId, StudyNewRequest body, String authorization, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        // verify the required parameter 'studyDbId' is set
        if (studyDbId == null) {
            throw new ApiException("Missing the required parameter 'studyDbId' when calling studiesStudyDbIdPut(Async)");
        }
        
        Call call = studiesStudyDbIdPutCall(studyDbId, body, authorization, progressListener, progressRequestListener);
        return call;

        
        
        
        
    }

    /**
     * Update an existing Study
     * Update an existing Study with new data
     * @param studyDbId Identifier of the study. Usually a number, could be alphanumeric. (required)
     * @param body  (optional)
     * @param authorization HTTP HEADER - Token used for Authorization   &lt;strong&gt; Bearer {token_string} &lt;/strong&gt; (optional)
     * @return StudySingleResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public StudySingleResponse studiesStudyDbIdPut(String studyDbId, StudyNewRequest body, String authorization) throws ApiException {
        ApiResponse<StudySingleResponse> resp = studiesStudyDbIdPutWithHttpInfo(studyDbId, body, authorization);
        return resp.getData();
    }

    /**
     * Update an existing Study
     * Update an existing Study with new data
     * @param studyDbId Identifier of the study. Usually a number, could be alphanumeric. (required)
     * @param body  (optional)
     * @param authorization HTTP HEADER - Token used for Authorization   &lt;strong&gt; Bearer {token_string} &lt;/strong&gt; (optional)
     * @return ApiResponse&lt;StudySingleResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<StudySingleResponse> studiesStudyDbIdPutWithHttpInfo(String studyDbId, StudyNewRequest body, String authorization) throws ApiException {
        Call call = studiesStudyDbIdPutValidateBeforeCall(studyDbId, body, authorization, null, null);
        Type localVarReturnType = new TypeToken<StudySingleResponse>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Update an existing Study (asynchronously)
     * Update an existing Study with new data
     * @param studyDbId Identifier of the study. Usually a number, could be alphanumeric. (required)
     * @param body  (optional)
     * @param authorization HTTP HEADER - Token used for Authorization   &lt;strong&gt; Bearer {token_string} &lt;/strong&gt; (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public Call studiesStudyDbIdPutAsync(String studyDbId, StudyNewRequest body, String authorization, final ApiCallback<StudySingleResponse> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        Call call = studiesStudyDbIdPutValidateBeforeCall(studyDbId, body, authorization, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<StudySingleResponse>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for studytypesGet
     * @param page Used to request a specific page of data to be returned.  The page indexing starts at 0 (the first page is &#x27;page&#x27;&#x3D; 0). Default is &#x60;0&#x60;. (optional)
     * @param pageSize The size of the pages to be returned. Default is &#x60;1000&#x60;. (optional)
     * @param authorization HTTP HEADER - Token used for Authorization   &lt;strong&gt; Bearer {token_string} &lt;/strong&gt; (optional)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public Call studytypesGetCall(Integer page, Integer pageSize, String authorization, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // create path and map variables
        String localVarPath = "/studytypes";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        if (page != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("page", page));
        if (pageSize != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("pageSize", pageSize));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        if (authorization != null)
        localVarHeaderParams.put("Authorization", apiClient.parameterToString(authorization));

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new Interceptor() {
                @Override
                public Response intercept(Interceptor.Chain chain) throws IOException {
                    Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "AuthorizationToken" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }
    
    @SuppressWarnings("rawtypes")
    private Call studytypesGetValidateBeforeCall(Integer page, Integer pageSize, String authorization, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        Call call = studytypesGetCall(page, pageSize, authorization, progressListener, progressRequestListener);
        return call;

        
        
        
        
    }

    /**
     * Get the Study Types
     * Call to retrieve the list of study types.
     * @param page Used to request a specific page of data to be returned.  The page indexing starts at 0 (the first page is &#x27;page&#x27;&#x3D; 0). Default is &#x60;0&#x60;. (optional)
     * @param pageSize The size of the pages to be returned. Default is &#x60;1000&#x60;. (optional)
     * @param authorization HTTP HEADER - Token used for Authorization   &lt;strong&gt; Bearer {token_string} &lt;/strong&gt; (optional)
     * @return StudyTypesResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public StudyTypesResponse studytypesGet(Integer page, Integer pageSize, String authorization) throws ApiException {
        ApiResponse<StudyTypesResponse> resp = studytypesGetWithHttpInfo(page, pageSize, authorization);
        return resp.getData();
    }

    /**
     * Get the Study Types
     * Call to retrieve the list of study types.
     * @param page Used to request a specific page of data to be returned.  The page indexing starts at 0 (the first page is &#x27;page&#x27;&#x3D; 0). Default is &#x60;0&#x60;. (optional)
     * @param pageSize The size of the pages to be returned. Default is &#x60;1000&#x60;. (optional)
     * @param authorization HTTP HEADER - Token used for Authorization   &lt;strong&gt; Bearer {token_string} &lt;/strong&gt; (optional)
     * @return ApiResponse&lt;StudyTypesResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<StudyTypesResponse> studytypesGetWithHttpInfo(Integer page, Integer pageSize, String authorization) throws ApiException {
        Call call = studytypesGetValidateBeforeCall(page, pageSize, authorization, null, null);
        Type localVarReturnType = new TypeToken<StudyTypesResponse>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Get the Study Types (asynchronously)
     * Call to retrieve the list of study types.
     * @param page Used to request a specific page of data to be returned.  The page indexing starts at 0 (the first page is &#x27;page&#x27;&#x3D; 0). Default is &#x60;0&#x60;. (optional)
     * @param pageSize The size of the pages to be returned. Default is &#x60;1000&#x60;. (optional)
     * @param authorization HTTP HEADER - Token used for Authorization   &lt;strong&gt; Bearer {token_string} &lt;/strong&gt; (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public Call studytypesGetAsync(Integer page, Integer pageSize, String authorization, final ApiCallback<StudyTypesResponse> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        Call call = studytypesGetValidateBeforeCall(page, pageSize, authorization, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<StudyTypesResponse>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
}
